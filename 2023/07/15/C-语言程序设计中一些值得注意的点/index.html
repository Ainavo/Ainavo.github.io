
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  
  <script>window.icon_font = '4552607_tq6stt6tcg';window.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ"};</script>
  
  
  <title>
    C 语言程序设计中一些值得注意的点 |
    
    Ainavo&#39;s Blog
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
<link rel="stylesheet" href="/css/loader.css">

  <meta name="description" content="Notes:参考课程&lt;&lt;浙大瓮恺 C 语言程序设计&gt;&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="C 语言程序设计中一些值得注意的点">
<meta property="og:url" content="https://ainavo.github.io/2023/07/15/C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/index.html">
<meta property="og:site_name" content="Ainavo&#39;s Blog">
<meta property="og:description" content="Notes:参考课程&lt;&lt;浙大瓮恺 C 语言程序设计&gt;&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-15T05:14:46.000Z">
<meta property="article:modified_time" content="2024-08-26T00:35:59.241Z">
<meta property="article:author" content="Ainavo">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ainavo's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css">

  
  
  
  
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script>

  
    
<link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css">

    
<script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script>

    <script>
      new WOW({
        offset: 0,
        mobile: true,
        live: false
      }).init();
    </script>
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
          <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
          <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
          <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
        </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>

    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/">首页</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/archives">归档</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/about">关于</a>
      </span>
    
      <span class="main-nav-link-wrap">
        <span class="main-nav-icon"></span>
        <a class="main-nav-link" href="/friend">友链</a>
      </span>
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    <img fetchpriority="high" src="https://haowallpaper.com/link/common/file/previewFileImg/2c7ac10a09fb6eac11f1686a9c85232a2c7ac10a09fb6eac11f1686a9c85232a.png" alt="C 语言程序设计中一些值得注意的点">
  
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div id="logo-wrap">
        
          
          
            <a href="/" id="logo">
              <h1>C 语言程序设计中一些值得注意的点</h1>
            </a>
          
        
      </div>
      
        
        <h2 id="subtitle-wrap">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="outer">
          
          <section id="main"><article id="post-C-语言程序设计中一些值得注意的点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    <div class="article-meta">
      <div class="article-date wow slideInLeft">
  <a href="/2023/07/15/C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/" class="article-date-link">
    <time datetime="2023-07-15T05:14:46.000Z" itemprop="datePublished">2023-07-15</time>
  </a>
</div>

      

    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em>Notes</em>:参考课程<a target="_blank" rel="noopener" href="https://space.bilibili.com/1355742754">&lt;&lt;浙大瓮恺 C 语言程序设计&gt;&gt;</a></p>
<span id="more"></span>
<ul>
<li>
<p>scanf() 中格式字符中的字符是必须输入的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;print %d&quot;</span>, &amp;a) <span class="comment">//终端中输入必须是 &quot;print xxx&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运算符和算子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + c <span class="comment">// a, b, c 算子； =, + 运算符；</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运算符优先级</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>运算</th>
<th>结合关系</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>+</td>
<td>单目不变</td>
<td>自右向左</td>
<td>a*+b</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>单目取负</td>
<td>自右向左</td>
<td>a*-b</td>
</tr>
<tr>
<td>2</td>
<td>*</td>
<td>乘</td>
<td>自左向右</td>
<td>a*b</td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>除</td>
<td>自左向右</td>
<td>a/b</td>
</tr>
<tr>
<td>2</td>
<td>%</td>
<td>取余</td>
<td>自左向右</td>
<td>a%b</td>
</tr>
<tr>
<td>3</td>
<td>+</td>
<td>加</td>
<td>自左向右</td>
<td>a+b</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>减</td>
<td>自左向右</td>
<td>a-b</td>
</tr>
<tr>
<td>4</td>
<td>=</td>
<td>赋值</td>
<td>自右向左</td>
<td>a=b</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>a++ 和 ++a</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++<span class="number">1</span>; <span class="comment">// 返回结果 2；并实现 +1 功能；</span></span><br><span class="line"><span class="number">1</span>++; <span class="comment">// 返回结果 1；并实现 +1 功能；</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>循环 tips：</p>
<ul>
<li>如果有固定次数，用 for 循环： for(; ; 😉</li>
<li>如果必须执行一次：用 do_while 循环</li>
<li>其他情况用 while 循环</li>
</ul>
</li>
<li>
<p>跳出循环：</p>
<ul>
<li>break：跳出循环</li>
<li>continue：跳出本轮循环，继续下一轮</li>
<li>goto：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    ....</span><br><span class="line">    <span class="keyword">goto</span> out:</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>辗转相除法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果b等于0，计算结束，a就是最大公约数；</span></span><br><span class="line"><span class="comment">// 否则，计算a除以b的余数，让a等于b，b等于那个余数；</span></span><br><span class="line"><span class="comment">// 构建循环体。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, temp=%d\n&quot;</span>, a, b, temp);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的最大公约数为 %d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数字类型</p>
<ul>
<li>类型名称：int、long、double</li>
<li>输入输出时的格式化：%d、%ld、%lf</li>
<li>所表达数的范围：char &lt; short &lt; int &lt; float &lt; double</li>
<li>内存中所占据的大小：1 个字节到 16 个字节</li>
<li>内存中的表达形式：二进制数（补码）、编码</li>
</ul>
</li>
<li>
<p>sizeof：一个 int 表达一个寄存器的大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 1字节（8比特）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>)); <span class="comment">// 2字节</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 取决于编译器（CPU）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>)); <span class="comment">// 取决于编译器（CPU）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long long) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)); <span class="comment">// 8字节</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>补码的意义：补码和原码相加可以得到一个溢出的 0</p>
</li>
<li>
<p>整数的范围：对于一个字节（8 位）可以表达的是：</p>
<ul>
<li>00000000~11111111</li>
<li>11111111<sub>10000000–&gt;-1</sub>-128(作为补码来看)</li>
<li>00000001~01111111–&gt; 1~127</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%d, i=%d\n&quot;</span>, c, i); <span class="comment">// c=-1, i=255</span></span><br><span class="line">    <span class="comment">// 11111111</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000000 11111111</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>char(1 字节):-128~127</li>
<li>short(2):-32768~32767</li>
<li>int:取决于编译器（CPU），通常意义上是&quot;1 个字&quot; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>long(4 字节)</li>
<li>long long(8 字节)</li>
</ul>
</li>
<li>
<p>unsigned:表示纯二进制(主要为了做移位)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">255</span>;</span><br><span class="line">     <span class="type">int</span> i =<span class="number">255</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;c=%d, i=%d\n&quot;</span>, c, i);</span><br><span class="line">     <span class="comment">// 00000000 - 11111111 0~255 正常：-128~127</span></span><br><span class="line">     <span class="comment">// 00000000 00000000 00000000 11111111</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>整数输入输出：int 和 long long</p>
<ul>
<li>%d:int</li>
<li>%u:unsigned</li>
<li>%ld:long long</li>
<li>%lu: unsigned long long</li>
</ul>
</li>
<li>
<p>浮点数类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字长</th>
<th>范围</th>
<th>有效数字</th>
<th>scanf</th>
<th>printf</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>32</td>
<td>±(1.2x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>38</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>~3.40x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>38</mn></msup></mrow><annotation encoding="application/x-tex">10^{38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>), 0, ±inf, nan</td>
<td>7</td>
<td>%f</td>
<td>%f, %e(科学计数)</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>±(2.2x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>308</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-308}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>~1.79x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>308</mn></msup></mrow><annotation encoding="application/x-tex">10^{308}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>), 0, ±inf, nan</td>
<td>15</td>
<td>%lf</td>
<td>%f, %e(科学计数)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>超过范围的浮点数：</p>
<ul>
<li>printf 输出 inf 表示无穷大</li>
<li>printf 输出 nan 表示不存在的浮点数</li>
</ul>
</li>
<li>
<p>浮点运算的精度</p>
<ul>
<li>带小数点的字面量意思是 double 而非 float</li>
<li>float 需要用 f 或 F 后缀来表明身份<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c;</span><br><span class="line">a = <span class="number">1.345f</span>;</span><br><span class="line">b = <span class="number">1.123f</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2.468</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不相等！c=%.10f, 或%f\n&quot;</span>, c, c)  <span class="comment">// f1 == f2 可能失败 ； fabs(f1-f2) &lt; 1e-12 验证;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>浮点数的内部表达：</p>
<ul>
<li>sign(1 bit)：符号位</li>
<li>exponent(11 bit)：指数位</li>
<li>fraction(52 bit)：小数位</li>
</ul>
</li>
<li>
<p>字符类型</p>
<ul>
<li>char(字符)：printf 和 scanf 用%c 输入输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%d&quot;</span>, a);  <span class="comment">// 1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c&quot;</span>, a);  <span class="comment">// 49 ASIIC 码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>逃逸字符：用来表达无法打印出来的控制字符或者特殊字符，他由一个反斜杠&quot;&quot;开头，后面跟上另一个字符，这两个字符合起来，组成一个字符。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>回退一格</td>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\t</td>
<td>到下一个表格位</td>
<td>'</td>
<td>单引号</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\</td>
<td>反斜杠本身</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>自动类型转换：</p>
<ul>
<li>当运算符两边出现不一样类型时，会自动转换成较大（范围大）的类型；</li>
<li>char–&gt;short–&gt;int–&gt;long–&gt;long long</li>
<li>int–&gt;float–&gt;double</li>
<li>注：
<ul>
<li>对于 printf，任何小于 int 类型的都会转换成 int；float 会被转换成 double；</li>
<li>对于 scanf 则不会，要输入 short，需要 %hd</li>
</ul>
</li>
</ul>
</li>
<li>
<p>强制转换：优先级高于四则运算</p>
<ul>
<li>(类型)值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)<span class="number">32.3</span></span><br><span class="line">(<span class="type">short</span>)<span class="number">32</span></span><br></pre></td></tr></table></figure>
</li>
<li>注意小的变量不总能表达大的变量</li>
</ul>
</li>
<li>
<p>逻辑类型(bool)和逻辑运算</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>!a</td>
<td>如果 a 是 true 结果就是 false；如果 a 是 false，结果就是 true；</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>a &amp;&amp; b</td>
<td>如果 a 和 b 都是 true，结果就是 true；否则就是 false；</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a || b</td>
<td>如果 a 和 b 中有一个是 true，结果为 true；两个都为 false，结果为 false；</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>运算符优先级</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>（）</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>! + - ++ –</td>
<td>从右到左（单目的+和-）</td>
</tr>
<tr>
<td>3</td>
<td>_ / %</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td>+ -</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;= &gt;&gt;=</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>== !=</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>= += -= _= /= %=</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>条件运算符：自右向左</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m&lt;n ?  a:a+<span class="number">5</span> <span class="comment">// (条件) ? a : b</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>逗号运算符：所有运算符中优先级最低的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">10</span>; i&lt;j; i++, j--) <span class="comment">// 基本上只有 for 条件会用到</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>本地变量</p>
<ul>
<li>生存期：什么时候这个变量出现了，到什么时候它消亡了</li>
<li>作用域：在代码什么范围内可以访问这个变量（这个变量起作用）</li>
<li>对于本地变量，这两个问题答案是统一的：大括号内–块
<ul>
<li>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</li>
<li>块外面定义的变量在里面仍然有效</li>
<li>快里面定义了和外面同名的变量则掩盖了外面的</li>
<li>不能在一 个块中定义同名变量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>; <span class="comment">// 与函数名称相同</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 无参数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组的定义</p>
<ul>
<li>&lt;类型&gt; 变量名[元素数量]；</li>
<li>int grades[100];</li>
<li>double weight[20];</li>
</ul>
</li>
<li>
<p>元素必须是整数；</p>
<ul>
<li>数组：是一种容器(存放东西的东西)</li>
<li>其中所有元素都具有相同的数据类型；</li>
<li>一旦创建，不能改变大小；</li>
<li>*(数组中元素在内存中是连续依次排列的) -数组初始化：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>C99 中支持：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;[<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>用[n]在初始化数据中给出定位</li>
<li>没有定位的数据接在前面的位置后面，其余位置自动补零</li>
<li>也可以不给出数组大小，让编译器算</li>
<li>适合初始数据稀疏的数组</li>
</ul>
</li>
<li>
<p>数组的大小：sizeof(a)/sizeof(a[0])</p>
</li>
<li>
<p>数组的赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,&#125;;</span><br><span class="line"><span class="type">int</span> b[] = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组不能直接赋值</li>
<li>把一个数组元素交给另一个数组，必须采用遍历</li>
</ul>
</li>
<li>
<p>数组作为函数的参数时：</p>
<ul>
<li>数组作为函数参数，往往必须再用另一个参数来传入数组的长度</li>
<li>不能在 a[] 中 [] 给出数组大小</li>
<li>不能利用 sizeof 计算元素个数</li>
</ul>
</li>
<li>
<p>二维数组：</p>
<ul>
<li>a[i][j]是一个 int：表示第 i 行第 j 列</li>
<li>a[i, j]错误表达：表示 a[j] (&quot;<strong>,</strong>&quot;运算符)</li>
<li>列数必须有，行数可以省略</li>
</ul>
</li>
<li>
<p>运算符 &amp;</p>
<ul>
<li>scanf(&quot;%d, &amp;d)中&amp;：获取变量的地址</li>
<li>&amp;(a+b), &amp;(a++), &amp;(++a) 都会报错， &amp;右边只能是固定数</li>
</ul>
</li>
<li>
<p>指针：就是保存地址的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p, q;  <span class="comment">// p是一个指针，指向int 同下；q不是一个指针；</span></span><br><span class="line"><span class="type">int</span> *p, q; <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针作为参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">    f(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>访问地址变量*：</p>
<ul>
<li>*是一个单目运算符，用来访问指针的值表示的地址上的变量</li>
<li>可以作为左值或右值：
<ul>
<li>int k = *p</li>
<li>*p = k+1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指针应用场景：</p>
<ul>
<li>交换两个值</li>
<li>函数返回运算状态，结果通过指针返回</li>
</ul>
</li>
<li>
<p>指针最常见错误：指针未指向地址，就赋值</p>
</li>
<li>
<p>以下四种函数原型是等价的：</p>
<ul>
<li>int sum(int *ar, int n);</li>
<li>int sum(int *, int);</li>
<li>int sum(int ar[], int n);</li>
<li>int sum(int[], int);</li>
</ul>
</li>
<li>
<p>数组变量就是特殊的指针：</p>
<ul>
<li>数组变量本身表达地址：
<ul>
<li>int a[10]; int*p = a; //无需用&amp;取地址</li>
<li>但是数组的单元表达的是变量，需要用&amp;去取地址</li>
<li>a == &amp;a[0]</li>
</ul>
</li>
<li>[] 运算符可以对数组做，也可以对指针做：
<ul>
<li>p[0]&lt;==&gt;a[0]</li>
</ul>
</li>
<li>*运算符可以对指针做，也可以对数组做：
<ul>
<li>*a = 25;</li>
</ul>
</li>
<li>数组变量是 const 指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] &lt;==&gt; <span class="type">int</span> * <span class="type">const</span> a <span class="comment">// 因此两个数组间不能直接赋值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>指针与 const：</p>
<ul>
<li>指针是 const：表示一旦得到了某个变量的地址，不能再指向其他变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;i; <span class="comment">// q 是 const</span></span><br><span class="line">*q = <span class="number">26</span>； <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
<li>所指是 const：表示不能通过这个指针去修改那个变量（并不能使得那个变量成为 const）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//EEROR! (*p)是const</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j; <span class="comment">//OK</span></span><br><span class="line"><span class="comment">// i 可以变；p 可以变；*p 不可以变；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>例子：判断 const 和*的位置关系–const 在*前 *p 不能被修改；const 在*后 p(地址不能被修改)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;i;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p2 = &amp;i;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3 = &amp;i;</span><br><span class="line"><span class="comment">// 技巧：主要看 const 修饰的是 *p，还是 p</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针的计算：</p>
<ul>
<li>*(p+1)、*(p++)、*(p–)</li>
<li>*p++:
<ul>
<li>取出 p 所指的那个数据，完事顺便把 p 移到下个位置</li>
<li>*的优先级虽然高，但是没有++高</li>
<li>常用于数组类的连续空间操作</li>
<li>在某些 CPU 上，这可以直接被翻译成一条汇编指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ac[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ac[<span class="number">0</span>]; <span class="comment">// 等价 char *p = ac;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ac)/<span class="keyword">sizeof</span>(ac[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=ac; *p=<span class="number">-1</span>; p++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>指针比较：
<ul>
<li>&lt;, &lt;=, ==, &gt;, &gt;=, != 都可以对指针进行比较</li>
<li>比较它们在内存中的地址</li>
<li>数组中的 单元地址肯定是线性递增的</li>
</ul>
</li>
<li>0 地址：NULL 表示 0 地址</li>
<li>指针的类型不能相互赋值</li>
<li>指针类型转换
<ul>
<li>void* 表示不知道指针指向什么东西的指针
<ul>
<li>计算时与 char*相同(但不相通)</li>
</ul>
</li>
<li>指针也可以转换类型
<ul>
<li>int *p = &amp;i;void*q =(void*) p;</li>
<li>这并没有改变 p 所指的变量类型，而是让后人用不同的眼光通过 p 看它所指的变量–我不再当你是 int，我认为你就是个 void</li>
</ul>
</li>
</ul>
</li>
<li>指针的用途：
<ul>
<li>需要传入较大的数据时用作参数</li>
<li>传入数组后对数组做操作</li>
<li>函数返回不止一个结果
<ul>
<li>需要用函数来修改不止一个变量</li>
</ul>
</li>
<li>动态申请内存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态内存分配：malloc 返回的是 void*，需要强制类型转换(申请的是字节)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>free():释放内存</li>
</ul>
</li>
<li>
<p>字符数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;; <span class="comment">//不是C语言字符串，因为不能用字符串的方式做计算</span></span><br><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串：</p>
<ul>
<li>以 0（整数 0）结尾的一串字符
<ul>
<li>0 或’\0’是一样的，但是和’0’不同</li>
</ul>
</li>
<li>0 标志字符串的结束，但它不是字符串的一部分
<ul>
<li>计算字符串长度的时候不包括这个 0</li>
</ul>
</li>
<li>字符串以数组形式存在，以数组或指针的形式访问
<ul>
<li>更多是以指针的形式</li>
</ul>
</li>
<li>string.h 有很多处理字符串的函数</li>
</ul>
</li>
<li>
<p>字符串变量</p>
<ul>
<li>char *str = “Hello”; // 只读的，不能写</li>
<li>char word[] = “Hello”;</li>
<li>char line[10] = “Hello”; // 占位 6 个字符，结尾是 0</li>
<li>如果要构造一个字符串–&gt;数组</li>
<li>如果要处理一个字符串–&gt;指针</li>
</ul>
</li>
<li>
<p>字符串输入和输出</p>
<ul>
<li>char string[8];</li>
<li>scanf(“%s”, string); //scanf 读入一个单词（到空格、tab、回车为止）；scanf 不安全；</li>
<li>printf(“%s”, string);</li>
</ul>
</li>
<li>
<p>char **: a 是一个指针，指向另一个指针，那个指针指向一个字符串</p>
</li>
<li>
<p>char [][]</p>
</li>
<li>
<p>程序参数：</p>
<ul>
<li>int main(int argc, char const* argv[])</li>
<li>argv[0] 是命令本身</li>
</ul>
</li>
<li>
<p>单字符的输入输出：</p>
<ul>
<li>int putchar(int c); // 向标准写入一个字符；返回写了几个字符，EOF(-1)表示写入失败</li>
<li>int getchar(void); // 从标准输入读入一个字符</li>
</ul>
</li>
<li>
<p>string.h</p>
<ul>
<li>
<p>strlen:返回字符串长度，不含 0；</p>
</li>
<li>
<p>strcmp：比较两个字符串：</p>
<ul>
<li>0：s1 == s2</li>
<li>1：s1 &gt; s2</li>
<li>-1: s1 &lt; s2</li>
</ul>
</li>
<li>
<p>strcpy(char *restrict dst, const char *restrict src)：拷贝 src–&gt;dst;restrict 表明 src 和 dst 不重叠</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">mycpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span> *src)</span>&#123;</span><br><span class="line">    &lt;!-- <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(src[idx])&#123;</span><br><span class="line">        dst[idx] = src[idx];</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    dst[idx] = <span class="string">&#x27;\0&#x27;</span>; --&gt; <span class="comment">// 数组版本</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *rest = *dst;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        *dst = *src;</span><br><span class="line">        src++;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    mycpy(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>strcat：</p>
</li>
<li>
<p>strchr：字符串找字符从左往右，返回指向字符的地址（如果找第二个则，继续在返回的地址中找）</p>
</li>
<li>
<p>strrchr：字符串找字符从右往左，返回指向字符的地址</p>
</li>
<li>
<p>strstr：字符串中找字符串</p>
</li>
</ul>
</li>
<li>
<p>枚举：enum 枚举类型名字 {名字 0, 名字 1, 名字 2, …};</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>RED, YELLOW, GREEN&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种形式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x,</span><br><span class="line">    <span class="type">int</span> y</span><br><span class="line">&#125; p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piont</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x,</span><br><span class="line">    <span class="type">int</span> y</span><br><span class="line">&#125; p1, p2; <span class="comment">// 既声明有定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span> &#123;<span class="number">7</span>， <span class="number">31</span>， <span class="number">2023</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">miao</span> =</span> &#123;.month=<span class="number">7</span>, .year=<span class="number">2023</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>结构跟数组有点像：</p>
<ul>
<li>要访问整个结构，直接用结构变量的名字</li>
<li>对于整个结构，可以做赋值、取地址、也可以传递给函数参数
<ul>
<li>p1=(struct point){5, 10}; //相当于 p1.x=5, p1.y=10</li>
<li>p1 = p2; // 相当于 p1.x = p2.x; p1.y = p2.y;</li>
</ul>
</li>
</ul>
</li>
<li>
<p>和数组不同的点是：结构变量的名字并不是结构变量的地址，必须用&amp;运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输入结构：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> piont p)</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.y);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p.x, &amp;p.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向结构的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strcut date &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; myday;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday;</span><br><span class="line">(*p).month = <span class="number">12</span>; <span class="comment">// .优先级高于 *;</span></span><br><span class="line">p-&gt;month = <span class="number">12</span>;  <span class="comment">// 用-&gt;表示指针所指的结构变量中的成员</span></span><br></pre></td></tr></table></figure>
</li>
<li>结构体和指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    getStruct(&amp;y);</span><br><span class="line">    output(y);</span><br><span class="line">    output(*getStruct(&amp;y));</span><br><span class="line">    print(getStruct(&amp;y));</span><br><span class="line">    getStruct(&amp;y)-&gt;x = <span class="number">0</span>;</span><br><span class="line">    *getStruct(&amp;y) = (<span class="keyword">struct</span> point)&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2005</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型定义：自定义数据类型(typedef)</p>
<ul>
<li>typedef 用来声明一个已有数据类型的新名字比如：typedef int Length；</li>
<li>声明之后，Length 就可以替代 int</li>
<li>与结构体相关用法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; Date;  <span class="comment">// 简化了复杂的结构体，用 Date 代替 结构体</span></span><br><span class="line"><span class="type">int64_t</span> i = <span class="number">1000000000000</span>;</span><br><span class="line">Date d = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2005</span>&#125;; <span class="comment">// 简单又高效!!!</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>联合 union:共同使用一个空间</p>
</li>
<li>
<p>全局变量：</p>
<ul>
<li>定义在函数外面的变量是全局变量</li>
<li>全局变量具有全局的生存期和作用域
<ul>
<li>它们和任何函数都无关</li>
<li>在任何函数内部都可以使用它们</li>
</ul>
</li>
<li>初始化：没做初始化的全局变量会得到 0 值；指针会得到 NULL 值</li>
<li>只能用编译时刻已知的值来初始化全局变量</li>
<li>它们的初始化发生在 main 函数前</li>
</ul>
</li>
<li>
<p>静态本地变量：static [数据类型] name;</p>
<ul>
<li>实际上是特殊的全局变量</li>
<li>位于相同的内存区域</li>
<li>今天本地变量具有全局生存期，在函数内的局部作用域：
<ul>
<li>static 在这里的意思是局部作用域(本地可访问)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回指针的函数：</p>
<ul>
<li>返回本地变量的地址是危险的</li>
<li>返回全局变量或者静态本地变量的地址是安全的</li>
<li>返回在函数内的 malloc 的内存是安全的，但是容易造成问题</li>
<li>最好的做法是传入指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);  <span class="comment">// 12</span></span><br><span class="line">    g();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);  <span class="comment">// 24 p地址中的内容被覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;  <span class="comment">// 不好，容易出错；正确做法：传入指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>预编译处理指令</p>
<ul>
<li>#开头是预编译指令</li>
<li>不是 C 语言的成分，但是 C 语言离不开他们</li>
<li>#define 用来定义一个宏： #define PI 3.14159 // 不能加 ;，因为不是 C 的语句</li>
<li>预定义宏：
<ul>
<li>__LINE__</li>
<li>__FILE__</li>
<li>__DATE__</li>
<li>__TIME__</li>
<li>__STDC__</li>
</ul>
</li>
</ul>
</li>
<li>
<p>带参数的宏：所有用到参数的地方都要有括号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG(x) ((x)*3.14)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多个.c 文件：</p>
<ul>
<li>main()里的代码太长了适合分成几个函数</li>
<li>一个源码文件太长了适合分成几个文件</li>
<li>两个独立的源码文件不能编译成可执行文件</li>
</ul>
</li>
<li>
<p>头文件：</p>
<ul>
<li>把函数原型放到一个头文件（以.h 结尾）中，在需要调用这个函数的原代码文件（.c 文件）中 #include 这个头文件，就能让编译器在编译的时候知道函数原型。</li>
<li>#include 有两种形式指出要插入的文件
<ul>
<li>&quot;&quot;要求编译器首先在当前目录（.c 所在目录）寻找这个文件，如果没有，到编译器指定的目录去找</li>
<li>&lt;&gt;让编译器只在指定的目录下找</li>
</ul>
</li>
<li>编译器自己知道自己的标准库的头文件在哪</li>
<li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li>
</ul>
</li>
<li>
<p>#include 误区：</p>
<ul>
<li>#include 不是用来引入库的</li>
<li>stdio.h 只有 printf 原型，printf 的代码再另外的地方，某个.lib(Windows)或.a(Unix)中。</li>
<li>现在的 C 语言编译器默认会引入所有的标准库</li>
<li>#include &lt;stdio.h&gt; 只是为了让编译器知道 printf 函数的原型，保证调用时给出的参数值是正确的类型</li>
</ul>
</li>
<li>
<p>声明 extern int i; // 变量的声明</p>
<ul>
<li>声明是不会产生代码的东西
<ul>
<li>函数原型</li>
<li>变量声明</li>
<li>结构声明</li>
<li>宏声明</li>
<li>枚举声明</li>
<li>类型声明</li>
<li>inline 函数</li>
</ul>
</li>
<li>定义是产生代码的东西</li>
<li>只有声明可以被放在头文件中
<ul>
<li>是规则不是法律</li>
</ul>
</li>
<li>否则会造成一个项目多个编译单元里有重名的实体
<ul>
<li>某些编译器允许几个编译单元中存在着同名的函数或者用 weak 修饰符来强调这种存在</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标准头文件结构(解决宏重复定义)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAX_H</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>格式化输入输出</p>
<ul>
<li>
<p>printf</p>
<ul>
<li>%[flags][width][.prec][hIL]type</li>
</ul>
<table>
<thead>
<tr>
<th>Flag</th>
<th>含义</th>
<th>width 或 prec</th>
<th>含义</th>
<th>类型修饰</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>左对齐</td>
<td>number</td>
<td>最小字符数</td>
<td>hh</td>
<td>单个字节</td>
</tr>
<tr>
<td>-</td>
<td>在前面放+或-</td>
<td>*</td>
<td>下一个参数是字符数</td>
<td>h</td>
<td>short</td>
</tr>
<tr>
<td>(space)</td>
<td>正数留空</td>
<td>.number</td>
<td>小数点后的位数</td>
<td>I</td>
<td>long</td>
</tr>
<tr>
<td>0</td>
<td>0 填充</td>
<td>.*</td>
<td>下一个参数是小数点后的位数</td>
<td>II</td>
<td>long long</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>type</th>
<th>用于</th>
<th>type</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>i 或 d</td>
<td>int</td>
<td>g</td>
<td>float</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>G</td>
<td>float</td>
</tr>
<tr>
<td>o</td>
<td>八进制</td>
<td>a 或 A</td>
<td>十六进制的浮点数</td>
</tr>
<tr>
<td>x</td>
<td>十六进制</td>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>X</td>
<td>字母大写的十六进制</td>
<td>s</td>
<td>字符串</td>
</tr>
<tr>
<td>f 或 F</td>
<td>float,6</td>
<td>p</td>
<td>指针</td>
</tr>
<tr>
<td>e 或 E</td>
<td>指数</td>
<td>n</td>
<td>读入/写入的个数</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>scanf</p>
<ul>
<li>%[flag]type</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>含义</th>
<th>flag</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>跳过</td>
<td>I</td>
<td>long, double</td>
</tr>
<tr>
<td>数字</td>
<td>最大字符数</td>
<td>II</td>
<td>long long</td>
</tr>
<tr>
<td>hh</td>
<td>char</td>
<td>L</td>
<td>long double</td>
</tr>
<tr>
<td>h</td>
<td>short</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>type</th>
<th>用于</th>
<th>type</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>int</td>
<td>a, e, f, g</td>
<td>float</td>
</tr>
<tr>
<td>i</td>
<td>整数，可能为十六进制或者八进制</td>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
<td>s</td>
<td>字符串（单词）</td>
</tr>
<tr>
<td>o</td>
<td>八进制</td>
<td>[…]</td>
<td>所允许的字符</td>
</tr>
<tr>
<td>x</td>
<td>十六进制</td>
<td>p</td>
<td>指针</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>文件的输入和输出</p>
<ul>
<li>用 &gt; 和 &lt; 做重定向：&lt; 指定一个文件作为输入，&gt; 指定一个文件写入输出</li>
<li>FILE* fopen(const char8 restrict path, const char* restrict mode);</li>
<li>int fclose(FILE *stream);</li>
<li>fscanf(FILE*, …)</li>
<li>fprintf(FILE*, …)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp)&#123;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, ...);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>fopen</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>打开只读</td>
</tr>
<tr>
<td>r+</td>
<td>打开读写，从文件头开始</td>
</tr>
<tr>
<td>w</td>
<td>打开只写。如果不存在则新建，如果存在则清空</td>
</tr>
<tr>
<td>w+</td>
<td>打开读写。如果不存在则新建，如果存在则清空</td>
</tr>
<tr>
<td>a</td>
<td>打开追加。如果不存在则新建，如果存在则从文件尾开写</td>
</tr>
<tr>
<td>…x</td>
<td>只新建，如果文件已存在，则不能打开</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>二进制文件</p>
<ul>
<li>其实所有文件最终都是二进制</li>
<li>文本文件无非是最简单的方式可以读写的文件
<ul>
<li>more、tail</li>
<li>cat</li>
<li>vi</li>
</ul>
</li>
<li>而二进制文件是需要专门的程序来读写的问间</li>
<li>文本文件的输入输出时格式化，可能经过转码</li>
<li>size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);</li>
<li>size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);</li>
<li>返回成功读写的字节数</li>
</ul>
</li>
<li>
<p>按位运算</p>
<ul>
<li>&amp;：按位取与
<ul>
<li>两个数都是 1，则为 1</li>
<li>应用：
<ul>
<li>让某一位或某些位置零：x &amp; 0xFE</li>
<li>取一个数中的一段：x &amp; 0xFF</li>
</ul>
</li>
</ul>
</li>
<li>|：按位取或
<ul>
<li>有 1 则 1</li>
<li>应用：
<ul>
<li>使一位或几位为 1：x | 0x01</li>
<li>把两个数拼起来：0x00FF | 0xFF00</li>
</ul>
</li>
</ul>
</li>
<li>~：按位取反
<ul>
<li>把 1 变成 0, 0 变成 1</li>
<li>应用：
<ul>
<li>想要得到全部位为 1 的数：~0</li>
<li>7 的二进制是 0111，x | 7 使得低 3 位为 1，而 x &amp; ~7，就使得低 3 位为 0；</li>
</ul>
</li>
</ul>
</li>
<li>^：按位的异或
<ul>
<li>两位相同结果为 0，不同为 1</li>
<li>应用：
<ul>
<li>如果 x 和 y 相等，那么 x^y 的结果是 0；</li>
<li>对于一个变量做两次异或相当于什么都没做：
<ul>
<li>x ^ y ^ x ==&gt; y</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>&lt;&lt;：左移
<ul>
<li>i &lt;&lt; j：i 中所有位想左移动 j 个位置，而右边填入 0；</li>
<li>所有小于 int 的类型，移位以 int 方式来做结果还是 int：
<ul>
<li>x &lt;&lt; 1 等价于 x *= 2;</li>
<li>x &lt;&lt; n 等价于 x *= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>;</li>
</ul>
</li>
</ul>
</li>
<li>&gt;&gt;：右移
<ul>
<li>i 中所有的位向右移 j 位</li>
<li>所有小于 int 的类型，移位以 int 的方式来做，结果是 int</li>
<li>对于 unsigned 类型，左边填入 0；</li>
<li>对于 signed 的类型，左边填入原来最高位(保持符号不变)
<ul>
<li>x &gt;&gt; 1 等价于 x /=2;</li>
<li>x &gt;&gt; n 等价于 x /= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>位段：把一个 int 的若干位组合成一个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> leading : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> trailing : <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以直接用位段的成员名称来访问
<ul>
<li>比位、与、或方便</li>
<li>编译器会安排其中的位的排列，不具有可移植性</li>
<li>当所需的位超过一个 int 时会采用多个 int</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可变数组</p>
<ul>
<li>Array array_create(int init_size); // 创建</li>
<li>void array_free(Array *a); // 回收</li>
<li>int array_size(const Array *a); // 数组大小</li>
<li>int* array_at(Array *a, int index); // 访问某个单元</li>
<li>void array_inflate(Array *a, int more_size); // 增长</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; Array;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BLOCK_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a;</span><br><span class="line">    a.size = init_size;</span><br><span class="line">    a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*a.size);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_size</span><span class="params">(Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装（保护 a-&gt;size）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span></span><br><span class="line">&#123;   <span class="keyword">if</span> (index &gt;= a-&gt;size)&#123;</span><br><span class="line">    array_inflate(a, (index/BLOCK_SIZE+<span class="number">1</span>)*BLOCK_SIZE - a-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)(a-&gt;size+more_size));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;a-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = a-&gt;<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p;</span><br><span class="line">    a-&gt;size += more_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a = array_create(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, array_size(&amp;a));</span><br><span class="line">    *array_at(&amp;a, <span class="number">0</span>) = <span class="number">10</span>;  <span class="comment">// array_at 返回的是地址，因此直接*取地址中的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *array_at(&amp;a, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)</span><br><span class="line">            *array_at(&amp;a, cnt++) = number;</span><br><span class="line">    &#125;</span><br><span class="line">    array_free(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链表：数据+指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// add to linked-list</span></span><br><span class="line">            Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            p-&gt;value = number;</span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// find the last</span></span><br><span class="line">            Node *last = head;</span><br><span class="line">            <span class="keyword">if</span> (last)&#123;</span><br><span class="line">                <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">                    last = last-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// attach</span></span><br><span class="line">                last-&gt;next = p;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; head = p ;&#125;  <span class="comment">// 初始 head = NULL，当有了第一个 p，应该指向 p</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表函数–(以下摘抄自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40570751/article/details/113513975?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;utm_relevant_index=3">翁恺 程序设计进阶 C 语言笔记-链表(Linked List)</a>)：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1，不行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head = p;       <span class="comment">//形参在函数结束的时候就会释放，如果没有直接将内存里的数改掉，那么对指针的操作也带不到函数外面去</span></span><br><span class="line">        <span class="comment">//在这里head是形参指针，出了函数以后head就被释放了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//证明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* t = &amp;b;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,*p);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数外：%d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* p)</span>&#123;</span><br><span class="line">    p = t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数内：%d\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出为</span></span><br><span class="line"><span class="comment">函数内：2</span></span><br><span class="line"><span class="comment">函数外：1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2，将指针的值返回</span></span><br><span class="line">Node* <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">head = add(head,number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案3，穿入指针的指针</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">add(&amp;head,number);   <span class="comment">//对head取地址，就是head这个指针的指针传进去了</span></span><br><span class="line"></span><br><span class="line">add(Node**  phead,<span class="type">int</span> number)&#123;     <span class="comment">//两个*，表示指针的指针</span></span><br><span class="line">    ...    <span class="comment">//head等价于*phead，将head全改为*phead</span></span><br><span class="line">    <span class="comment">//return head;   不需要返回了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案四</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>&#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;   <span class="comment">//可以拓展功能，增加tail总是指向链表的末尾，然后不用遍历了，直接将tail指向新指针即可</span></span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//实现读入一个数字就存起来，知道读到-1为止</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>.head = <span class="literal">NULL</span>;    <span class="comment">//定义链表的头部，这是一个指向Node类型结构体的指针</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//添加一个新的链表（数据块）,加在程序的最后面</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">            add(&amp;<span class="built_in">list</span>,number);     <span class="comment">//传入指向head的指针</span></span><br><span class="line">            Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));    <span class="comment">//指针p指向新创建的链表，用malloc给他开辟内存</span></span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//新加入的链表放到最后面，所以是空指针</span></span><br><span class="line">            p-&gt;value = number;</span><br><span class="line">            <span class="comment">//找到最后的那个链表</span></span><br><span class="line">            Node *last = head;  <span class="comment">//设用last指向最后那个链表，先设last为head</span></span><br><span class="line">            <span class="comment">//last和head一样，是指向头链表的指针 *head就是头链表那个结构体 last-&gt;next 等价于 (*head).next</span></span><br><span class="line">            <span class="comment">//判断last不为空，如果整个链表为空,此时head=NULL，last-&gt;就是NULL的next元素，这样是非法的，所以要判断</span></span><br><span class="line">            <span class="keyword">if</span> (last)&#123;</span><br><span class="line">                <span class="comment">/*遍历，不能用if，这里是只要last指向的结构体的指针不为空，</span></span><br><span class="line"><span class="comment">                即指向的链表的下一个链表不为空，则不停止循环，if只判断一次*/</span></span><br><span class="line">                <span class="keyword">while</span> (last-&gt;next)&#123;</span><br><span class="line">                                last = last-&gt;next;   <span class="comment">//指向下一个链表</span></span><br><span class="line">                            &#125;</span><br><span class="line">                last-&gt;next = p;    <span class="comment">/*last-&gt;next等于NULL了，说明last已经指向原本的最后一个链表了，这里让last的next为我们新添加的链表</span></span><br><span class="line"><span class="comment">                就是将老链表的最后一个中的next指针指向我们添加的新链表*/</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = p;   <span class="comment">//空链表，直接将head指向我们新创建的链表，此时新链表是头链表，也是唯一的链表。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>( number != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List* pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = pList-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pList-&gt;head = p;  <span class="comment">// 跟两数交换的原理一样，对指针指向的内容进行赋值(只不过赋的值是地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>链表的搜索：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span>(p=pList-&gt;head; p; p = p-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链表的删除：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *q;</span><br><span class="line"><span class="keyword">for</span> (q=<span class="literal">NULL</span>, p=head; p; q=p,p=p-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;value == number)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q)&#123;                     <span class="comment">// p-&gt; 中的 p 必须保证是非 NULL</span></span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">list</span>.head -&gt; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的清除：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p=head; p; p=q)&#123;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XZ4y1S7e1/?p=1&amp;vd_source=3a9f66a8e4f96fbd39b999e86b2e0cf4">C 语言程序设计–翁恺</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40570751/article/details/113513975?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;utm_relevant_index=3">翁恺 程序设计进阶 C 语言笔记-链表(Linked List)</a> 强推!!总结的很好</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>


    </footer>
  </div>
  
    
  <nav id="article-nav" class="wow fadeInUp">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          <img data-src="https://haowallpaper.com/link/common/file/previewFileImg/8b494120655a1cfb41a19e7af3060d028b494120655a1cfb41a19e7af3060d02.jpg" data-sizes="auto" alt="结构体" class="lazyload">
        
        <a href="/2023/07/21/%E7%BB%93%E6%9E%84%E4%BD%93/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            结构体
          
        </h3>
      </div>
    
    
  </nav>


  
</article>






</section>
          
            <aside id="sidebar">
  <div class="sidebar-wrap wow fadeInRight wrap-sticky">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="Ainavo" class="lazyload">
  <div class="sidebar-author-name">Ainavo</div>
  <div class="sidebar-description">一个菜猫</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">9</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">10</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
    
      <div class="sidebar-btn-wrapper" style="position:static">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  </div>

  
</aside>

          
        </div>
        <footer id="footer" class="wow fadeInUp">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div class="outer">
    <div id="footer-info">
      
      <div>
        <span class="icon-copyright"></span>
        2020-2024
        <span class="footer-info-sep"></span>
        Ainavo
      </div>
      
        <div>
          基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
          Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
        </div>
      
      
        <div>
          <span class="icon-brush"></span>
          31.2k
          &nbsp;|&nbsp;
          <span class="icon-coffee"></span>
          02:00
        </div>
      
      
        <div>
          <span class="icon-eye"></span>
          <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
          &nbsp;|&nbsp;
          <span class="icon-user"></span>
          <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
        </div>
      
    </div>
  </div>
</footer>

        <div class="sidebar-top">
          <img src="/images/taichi.png" height="50" width="50" alt="backtop" />
          <div class="arrow-up"></div>
        </div>
        <div id="mask"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="Ainavo" class="lazyload">
  <div class="sidebar-author-name">Ainavo</div>
  <div class="sidebar-description">一个菜猫</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">9</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">10</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">首页</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">归档</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">关于</div>
    </div>
  
    <div class="sidebar-menu-link-wrap">
      <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
      <span class="sidebar-menu-icon"></span>
      <div class="sidebar-menu-link">友链</div>
    </div>
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    <div class="site-search">
      <div class="reimu-popup popup">
        <div class="reimu-search">
          <span class="reimu-search-input-icon"></span>
          <div class="reimu-search-input" id="reimu-search-input"></div>
        </div>
        <div class="reimu-results">
          <div id="reimu-stats"></div>
          <div id="reimu-hits"></div>
          <div id="reimu-pagination" class="reimu-pagination"></div>
        </div>
        <span class="popup-btn-close"></span>
      </div>
    </div>
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script>



<script src="/js/script.js"></script>



<script src="/js/pjax_script.js" data-pjax></script>


<script type="module" data-pjax>
  import PhotoSwipeLightbox from "https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.js";
  
  const pswp = () => {
    if (_$$('.article-entry a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-entry',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.js")
      }).init();
    }
    if(_$$('.article-gallery a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-gallery',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.js")
      }).init();
    }
    window.lightboxStatus = 'done';
    window.removeEventListener('lightbox:ready', pswp);
  }
  if(window.lightboxStatus === 'ready') {
    pswp()
  } else {
    window.addEventListener('lightbox:ready', pswp);
  }
</script>
















  
<script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script>

  <script>
    firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>






<div id="lazy-script">
  <div>
    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '0.2.2' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  


  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


  <!-- hexo injector body_end start -->
<script src="/js/insert_highlight.js" data-pjax></script>
<!-- hexo injector body_end end --></body>
  </html>

