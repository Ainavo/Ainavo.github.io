<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BMS之SOC综述</title>
      <link href="/2024/09/20/BMS%E4%B9%8BSOC%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/09/20/BMS%E4%B9%8BSOC%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="soc-概述"><a class="markdownIt-Anchor" href="#soc-概述"></a> SOC 概述</h2><p>在电池管理系统（Battery Management System, BMS）中，SOC（State of Charge）是一个重要的概念，用于表示电池的剩余电量。SOC 算法是用于计算电池剩余电量的算法，它可以根据电池的充电和放电过程来估计电池的剩余电量。SOC 算法的准确性和实时性对于电池管理系统的正常运行非常重要。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>Q</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><msub><mi>Q</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mo>×</mo><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">    SOC(t)=\frac {Q_r(t)} {Q_{max}} \times 100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span></span></p><h2 id="soc-算法"><a class="markdownIt-Anchor" href="#soc-算法"></a> SOC 算法</h2><img src="/2024/09/20/BMS%E4%B9%8BSOC%E7%BB%BC%E8%BF%B0/SOC%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" class="" title="SOC算法总结"><h2 id="电车-soc-算法优势对比"><a class="markdownIt-Anchor" href="#电车-soc-算法优势对比"></a> 电车 SOC 算法优势对比</h2><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">    <tr>        <td style="text-align: center;"></td>        <td style="text-align: center;">方法</td>        <td style="text-align: center;">准确率</td>        <td style="text-align: center;">优点</td>        <td style="text-align: center;">缺点（面临的挑战）</td>    </tr>    <tr>        <td rowspan="3" style="text-align: center;">直接估量方法</td>        <td style="text-align: center;">安时积分法(CC)</td>        <td style="text-align: center;">&#10004&#10004&#10004</td>        <td style="text-align: center;">简单、低成本、实时性</td>        <td style="text-align: center;">累积误差、校准要求、有限精度</td>    </tr>    <tr>        <td style="text-align: center;">开路电压法(OCV)</td>        <td style="text-align: center;">&#10004&#10004</td>        <td style="text-align: center;">模型简单、对积分误差敏感性低、适用于静态</td>        <td style="text-align: center;">非线性和滞后性，依赖电池模型以及有限的动态响应</td>    </tr>    <tr>        <td style="text-align: center;">阻抗法(EIS)</td>        <td style="text-align: center;">&#10008</td>        <td style="text-align: center;">无损表征，信息全面，灵敏度高</td>        <td style="text-align: center;">复杂的解释、数据处理要求、高频准确度有限、对初始条件的依赖</td>    </tr>    <tr>        <td rowspan="2" style="text-align: center;">基于模型的算法</td>        <td style="text-align: center;">电路模型(ECM)</td>        <td style="text-align: center;">&#10004&#10004&#10004&#10004</td>        <td style="text-align: center;">实时能力、低计算复杂性、对校准的依赖性较小</td>        <td style="text-align: center;">精度有限、老化效应、动力学有限、对温度变化敏感</td>    </tr>    <tr>        <td style="text-align: center;">电化学模型(EChM)</td>        <td style="text-align: center;">&#10008</td>        <td style="text-align: center;">加入老化效应，精度高，适应不同条件，动态响应</td>        <td style="text-align: center;">计算复杂性，模型校准，有限的推广</td>    </tr>    <tr>        <td rowspan="3" style="text-align: center;">自适应滤波算法</td>        <td style="text-align: center;">基于卡尔曼滤波(KF)</td>        <td style="text-align: center;">&#10004&#10004&#10004&#10004</td>        <td style="text-align: center;">实时估算、多数据源集成、系统动态适应性</td>        <td style="text-align: center;">模型复杂性、传感器噪声和误差、初始化灵敏度、线性假设</td>    </tr>    <tr>        <td style="text-align: center;">递归最小二乘法(RLS)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">对初始化的敏感性低，对非线性的适应性，处理噪声测量的能力</td>        <td style="text-align: center;">模型复杂性、内存需求、对测量质量的依赖性</td>    </tr>    <tr>        <td style="text-align: center;">基于 H(∞)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">鲁棒性，对不确定性的适应性，干扰下的性能</td>        <td style="text-align: center;">复杂性、计算强度、建模要求、对非线性的适应性有限</td>    </tr>    <tr>        <td rowspan="6" style="text-align: center;">自适应人工智能算法</td>        <td style="text-align: center;">基于遗传算法(GA)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">全局优化，并行处理，适应非线性，不需要导数</td>        <td style="text-align: center;">计算强度，依赖于初始种群，可扩展性有限</td>    </tr>    <tr>        <td style="text-align: center;">模糊神经网络(ANFIS)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">非线性近似，对不确定性的适应性，从数据中学习，基于规则的可解释性</td>        <td style="text-align: center;">复杂的参数调整，数据需求过拟合，可解释性权衡，计算强度</td>    </tr>    <tr>        <td style="text-align: center;">前馈神经网络(ANN)</td>        <td style="text-align: center;">&#10004&#10004</td>        <td style="text-align: center;">非线性逼近，系统动力学适应性，数据学习，并行处理，特征提取</td>        <td style="text-align: center;">数据要求、过拟合、复杂参数调整、缺乏可解释性、计算强度</td>    </tr>    <tr>        <td style="text-align: center;">深度学习(DL)</td>        <td style="text-align: center;">&#10004&#10004</td>        <td style="text-align: center;">分层特征学习，对不同数据的适应性，端到端学习</td>        <td style="text-align: center;">数据需求、可解释性、过拟合、复杂性和参数调整</td>    </tr>    <tr>        <td style="text-align: center;">模糊逻辑(FL)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">可解释性、基于规则的系统、适应性、简单性和易于实施</td>        <td style="text-align: center;">学习能力有限，对规则参数敏感，泛化能力有限</td>    </tr>    <tr>        <td style="text-align: center;">支持向量机(SVM)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">在高维空间中有效，非线性关系的核技巧，全局优化，泛化正则化</td>        <td style="text-align: center;">大型数据集的内存密集型，有限的可解释性，难以处理噪声数据，对不断变化的条件的适应性有限</td>    </tr>    <tr>        <td rowspan="2" style="text-align: center;">高级算法</td>        <td style="text-align: center;">迁移学习(TL)</td>        <td style="text-align: center;">&#10004</td>        <td style="text-align: center;">提高数据效率，减少培训时间，增强稳健性，解决有限的数据可用性问题</td>        <td style="text-align: center;">模型过拟合、可移植性问题、微调挑战</td>    </tr>    <tr>        <td style="text-align: center;">融合算法(Hybird methods)</td>        <td style="text-align: center;">&#10004&#10004</td>        <td style="text-align: center;">提高数据效率，减少培训时间，增强稳健性，解决有限的数据可用性问题</td>        <td style="text-align: center;">复杂的实现，模型融合挑战，参数调整复杂性，计算负载</td>    </tr></table>注：&#10004&#10004&#10004&#10004：非常高   &#10004&#10004&#10004：高   &#10004&#10004：中   &#10004：低   &#10008：尚未直接在电车系统中使用<h2 id="soc-算法详细展开"><a class="markdownIt-Anchor" href="#soc-算法详细展开"></a> SOC 算法详细展开</h2><h3 id="安时积分法"><a class="markdownIt-Anchor" href="#安时积分法"></a> 安时积分法</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi>O</mi><msub><mi>C</mi><mn>0</mn></msub><mo>−</mo><mi>η</mi><mfrac><mrow><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><msub><mi>Q</mi><mi>n</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">    SOC(t)=SOC_0-\eta\frac{\int_{0}^{t} i(t) dt}{Q_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.614716em;vertical-align:-0.8804400000000001em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.734276em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74582em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.988456em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h3><ul><li>Demirci O, Taskin S, Schaltz E, et al. Review of battery state estimation methods for electric vehicles-Part I: SOC estimation[J]. Journal of Energy Storage, 2024, 87: 111435.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> BMS </tag>
            
            <tag> SOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb C语言调试</title>
      <link href="/2024/09/19/gdb-C%E8%AF%AD%E8%A8%80%E8%B0%83%E8%AF%95/"/>
      <url>/2024/09/19/gdb-C%E8%AF%AD%E8%A8%80%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>示例函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, sum;</span><br><span class="line">  <span class="keyword">for</span> (i = low; i &lt;= high; i++)</span><br><span class="line">    sum += i;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result1;</span><br><span class="line">  <span class="type">int</span> result2;</span><br><span class="line">  result1 = add_range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">  result2 = add_range(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result1 = %d\n&quot;</span>, result1);  <span class="comment">// res1=5050</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result2 = %d\n&quot;</span>, result2);  <span class="comment">// res2=500500</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单步执行和跟踪函数调用"><a class="markdownIt-Anchor" href="#单步执行和跟踪函数调用"></a> 单步执行和跟踪函数调用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -g main.c -o main  # 编译程序</span><br><span class="line">gdb main  # 启动gdb</span><br><span class="line">list  # 查看代码</span><br><span class="line">run   # 运行程序</span><br><span class="line">next  # 单步执行</span><br><span class="line">step  # 跟踪函数调用</span><br><span class="line">finish  # 退出当前函数</span><br><span class="line">continue  # 继续执行程序</span><br><span class="line">quit  # 退出gdb</span><br></pre></td></tr></table></figure><h2 id="断点"><a class="markdownIt-Anchor" href="#断点"></a> 断点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">break  # 设置断点</span><br><span class="line">break main(函数名)  # 设置断点在main函数</span><br><span class="line">break 行号  # 设置断点在指定行号</span><br><span class="line">info breakpoints  # 查看断点</span><br><span class="line">delete breakpoints  # 删除断点</span><br><span class="line">clear  # 清除所有断点</span><br><span class="line">disable breakpoints  # 禁用断点</span><br><span class="line">enable breakpoints  # 启用断点</span><br><span class="line">condition breakpoints  # 设置断点条件</span><br><span class="line">undisplay 跟踪显示号  # 取消跟踪显示</span><br></pre></td></tr></table></figure><h2 id="观察点"><a class="markdownIt-Anchor" href="#观察点"></a> 观察点</h2><p>观察点是一种特殊的断点，它会在程序执行时自动停止，当被观察的变量的值发生变化时，程序会自动停止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch 变量名  # 观察变量值</span><br><span class="line">info watchpoints  # 查看观察点</span><br><span class="line">delete watchpoints  # 删除观察点</span><br><span class="line">clear  # 清除所有观察点</span><br><span class="line">disable watchpoints  # 禁用观察点</span><br><span class="line">enable watchpoints  # 启用观察点</span><br></pre></td></tr></table></figure><h2 id="段错误"><a class="markdownIt-Anchor" href="#段错误"></a> 段错误</h2><p>gdb 可以很容易定位到究竟是哪一行引发的段错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMWare虚拟机常见问题备注</title>
      <link href="/2024/08/05/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8/"/>
      <url>/2024/08/05/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="网络链接相关"><a class="markdownIt-Anchor" href="#网络链接相关"></a> 网络链接相关</h2><h3 id="vmware-在桥接模式下连网"><a class="markdownIt-Anchor" href="#vmware-在桥接模式下连网"></a> VMWare 在桥接模式下连网</h3><ul><li><p>VMWare 提供了三种网络工作模式：</p><ul><li>Bridge（桥接模式）：桥接模式就是将主机网卡和虚拟机的网卡利用虚拟网桥进行通信</li><li>NAT（网络地址转换模式）：模式是一种常用的网络连接方式，主要用于在虚拟化环境中管理网络流量。NAT 模式允许虚拟机通过宿主机访问外部网络，但外部网络无法直接访问虚拟机</li><li>Host-Only（仅主机模式）：是一种虚拟机网络模式，允许虚拟机与宿主机之间进行通信，同时阻止它与外部网络进行通信。这种模式常用于需要保证虚拟机之间或者虚拟机与宿主机之间进行数据传输，但不希望与外部网络直接连接的场景</li></ul></li><li><p><strong>桥接模式下选择对应网卡</strong></p></li><li><p>查看主机网卡信息：</p><img src="/2024/08/05/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8/%E6%9F%A5%E7%9C%8B%E7%89%A9%E7%90%86%E6%9C%BA%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF.png" class="" title="查看主机网卡信息"></li><li><p>在 VMWare 左上角找到“编辑”——&gt;“虚拟网络编辑器”，更改桥接模式连接</p><img src="/2024/08/05/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8/%E6%9B%B4%E6%94%B9%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF.png" class="" title="更改桥接模式网卡信息"></li><li><p>设置桥接模式连接主机网卡</p><img src="/2024/08/05/VMWare%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8/%E8%AE%BE%E7%BD%AE%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BA%E7%BD%91%E5%8D%A1.png" class="" title="设置桥接模式连接主机网卡"><p>参考文献：</p></li><li><p><a href="https://blog.csdn.net/weixin_44924882/article/details/134106059">VM Ware 在桥接模式下无法联网</a></p></li></ul><h3 id="开发板-ping-主机-主机-ping-虚拟机-虚拟机-ping-开发板-开发板-ping-网络"><a class="markdownIt-Anchor" href="#开发板-ping-主机-主机-ping-虚拟机-虚拟机-ping-开发板-开发板-ping-网络"></a> 开发板 PING 主机、主机 PING 虚拟机、虚拟机 PING 开发板、开发板 PING 网络</h3><ul><li>主机 IP（Win+R–&gt;ipconfig 查看）：192.168.196.74 网关：192.168.196.126</li><li>虚拟机 IP（桥接模式）:192.168.196.11</li><li>开发板：192.168.196.232 网关：192.168.196.100（手动配置）</li><li>网关</li></ul><h2 id="文件传输相关"><a class="markdownIt-Anchor" href="#文件传输相关"></a> 文件传输相关</h2><h3 id="vmware-和主机相互传输文件"><a class="markdownIt-Anchor" href="#vmware-和主机相互传输文件"></a> VMWare 和主机相互传输文件</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用串口协议栈</title>
      <link href="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
      <url>/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>A</mi><mi>R</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">UART</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mrow></mrow><mn>2</mn></msup><mi>C</mi></mrow><annotation encoding="application/x-tex">I{^2}C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>P</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">SPI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>A</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">CAN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>S</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">USB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>Q</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MQTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">Q</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>I</mi><mi>F</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">WIFI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">UDP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>C</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">TCP/IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">....</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p><span id="more"></span><h1 id="常见的通信协议"><a class="markdownIt-Anchor" href="#常见的通信协议"></a> 常见的通信协议</h1><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">    <tr>        <td colspan="2" style="text-align: center;">通信协议</td>        <td style="text-align: center;">串行/并行</td>        <td style="text-align: center;">传输方向</td>        <td style="text-align: center;">同步/异步</td>        <td style="text-align: center;">电平逻辑</td>        <td style="text-align: center;">主从组成</td>    </tr>    <tr>        <td rowspan="3" style="text-align: center;">UART</td>        <td style="text-align: center;">TTL</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">全双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主一从</td>    </tr>    <tr>        <td style="text-align: center;">RS232</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">全双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主一从</td>    </tr>    <tr>        <td style="text-align: center;">RS485</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">半双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">差分信号</td>        <td style="text-align: center;">一主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">USART</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">全双工</td>        <td style="text-align: center;">同步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主一从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">I2C</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">半双工</td>        <td style="text-align: center;">同步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">SPI</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">全双工</td>        <td style="text-align: center;">同步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">CAN</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">半双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">差分信号</td>        <td style="text-align: center;">多主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">1-Wire</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">半双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">逻辑电平</td>        <td style="text-align: center;">一主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">USB2.0</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;">半双工</td>        <td style="text-align: center;">异步</td>        <td style="text-align: center;">差分信号</td>        <td style="text-align: center;">一主多从</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">MQTT</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">WIFI</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">UDP</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">TCP/IP</td>        <td style="text-align: center;">串行</td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>        <td style="text-align: center;"></td>    </tr></table><h2 id="uart-通信协议"><a class="markdownIt-Anchor" href="#uart-通信协议"></a> UART 通信协议</h2><p>UART（Universal Asynchronous Receiver/Transmitter，通用异步收发器）是一种双向、串行、异步通信总线。</p><h3 id="uart-的硬件链接"><a class="markdownIt-Anchor" href="#uart-的硬件链接"></a> UART 的硬件链接</h3><p>UART 串口需要 3 根线通信，分别是 TXD（发送线）、RXD（接收线）和 GND（地线），如下图 1-1 所示。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/UART%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5.png" class="" title="图1-1 UART硬件连接"><center> 图1-1 UART硬件连接 </center><h3 id="uart-的电气特性"><a class="markdownIt-Anchor" href="#uart-的电气特性"></a> UART 的电气特性</h3><ul><li>高电平：通常为 2.5V~5V</li><li>低电平：通常为 0~0.8V</li><li>波特率：是指每秒传输的比特数，常用的波特率包括 9600、19200、38400、115200</li><li>最大的传输距离在几十厘米到几米之间</li></ul><h3 id="uart-的数据帧"><a class="markdownIt-Anchor" href="#uart-的数据帧"></a> UART 的数据帧</h3><p>UART 协议数据帧由起始位、数据帧、奇偶校验位和停止位组成，如图 1-2 所示。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/UART%E6%95%B0%E6%8D%AE%E5%B8%A7.png" class="" title="图1-2 UART数据帧"><center> 图1-2 UART数据帧 </center><ul><li>起始位：在不传输数据时，UART 保持在高电平状态。当 UART 信号从高电平拉低，并保持在低电平持续一个时钟周期时，这一状态被称为起始位。</li><li>数据位：数据帧中包含实际传输的数据，数据帧长度可以是 5~9 比特（不使用奇偶校验位），也可以是 5~8 比特（使用奇偶检验位）。</li><li>奇偶检验位：当接受端收到 UART 传输的数据帧后，如果奇偶校验位设置为 0（偶校验），则对应数据帧中高电平的个数应为偶数个；如果奇偶校验位设置为 1（奇校验），则对应数据帧中的高电平的个数应为奇数个。</li><li>停止位：UART 将数据传输线从低电平拉至高电平并保持 1~2 位时间</li></ul><h3 id="ttl"><a class="markdownIt-Anchor" href="#ttl"></a> TTL</h3><p>TTL（Transistor-Transistor Logic，晶体管-晶体管逻辑）是一种数字电路和逻辑电路的实现技术，主要使用晶体管作为基本的开关元件。TTL 电平用于串口通信时，有 3.3V 和 5V 两个系列。由于电压范围小，所以抗干扰能力较弱，传输的具体不远，在 9600 波特率传输距离为 2 米，一般不超过 15 米。降低波特率可以传输得更远，这个与电磁环境环境有关。可做全双工通信</p><ul><li>逻辑电平 TTL 的高电平通常在 2.4V~5V 之间，低电平通常在 0V~0.8V 之间，如图 1-3 所示<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/TTL%E7%94%B5%E5%B9%B3.png" class="" title="图1-3 TTL电平"><center> 图1-3 TTL电平 </center></li></ul><h3 id="rs232"><a class="markdownIt-Anchor" href="#rs232"></a> RS232</h3><p>RS232 是全双工通信，可以同时进行发送和接受数据，通信传输距离不超过 15 米，只使用 RXD、TXD、GND 三根线进行通信。RS232 采用负逻辑进行通信，逻辑&quot;1&quot;为-3V~-15V；逻辑&quot;0&quot;为 3~15V，如图 1-4 所示。相比于 TTL 电平抗干扰能力更强，可长距离传输，传输频率越低，传输距离越远，越稳定。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/RS232%E7%94%B5%E5%B9%B3.png" class="" title="图1-4 RS232电平"><center> 图1-4 RS232电平 </center><h3 id="rs485"><a class="markdownIt-Anchor" href="#rs485"></a> RS485</h3><p>RS485 采用双线半双工传输，最大速率 10MB/s，电平逻辑由双线的电平差决定，如图 1-5 所示。逻辑&quot;1&quot;为：+2V<sub>+6V，逻辑&quot;0&quot;为：-2V</sub>-6V，提高了抗干扰能力，传输距离几十米~几千米。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/RS485.svg" class="" title="图1-5 RS485电平"><center> 图1-5 RS485电平 </center><h2 id="i2c-通信协议"><a class="markdownIt-Anchor" href="#i2c-通信协议"></a> I2C 通信协议</h2><h3 id="i2c-的硬件特性"><a class="markdownIt-Anchor" href="#i2c-的硬件特性"></a> I2C 的硬件特性</h3><ul><li>包括 SCL、SDA 两条总线（如图 1-6 所示）</li><li>总线上的每个设备均可通过唯一的地址进行寻址，从机地址 7 位（因此理论上最大从机数 127）</li><li>传输速度：<ul><li>标准模式（Standard Mode）：100Kbps</li><li>快速模式（Fast Mode）：400Kbps</li><li>高速模式（High Speed Mode）：3.4Mbps</li><li>超快速模式（Ultra Fast Mode）：5Mbps</li></ul></li></ul><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/I2C%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5.png" class="" title="图1-6 I2C协议硬件连接示意图"><center> 图1-6 I2C协议硬件连接示意图 </center><h3 id="i2c-时序图"><a class="markdownIt-Anchor" href="#i2c-时序图"></a> I2C 时序图</h3><ul><li>开始条件（如图 1-7 所示）<ul><li>先将 SDA 从高电平拉到低电平</li><li>然后将 SCL 从高电平拉到低电平</li></ul></li></ul><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/I2C%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7.png" class="" title="图1-7 I2C开始与停止信号"><center> 图1-7 I2C开始与停止信号 </center><ul><li><p>地址位（小端模式）</p><ul><li>主设备与从设备间的通信地址</li><li>7 位寻址模式，地址帧的高 7 位为从机地址</li><li>10 位寻址模式，第一帧发送 7 位地址，然后在发送剩下的地址（有待验证）</li></ul></li><li><p>读写位:R/W–&gt;0：主机向从机写数据 1：主机从从机读数据（位于地址位的后一位–该字节的第八位）</p></li><li><p>应答位（每一帧数据后都要跟一个应答位以表示收到/未收到）</p><ul><li>ACK(0)：当发送地址与从机匹配，则从设备通过将 SDA 总线拉低表示 ACK 位；数据帧后的第 9 个时钟是应答位，是接收方向发送方传送的握手信号；</li><li>NACK(1)：当地址不匹配，则将 SDA 总线拉高表示 NACK；如果总线上从机接收数据，在第 9 个时钟周期不响应主机，从机必须发送 NACK。如果总线上主机接收数据，第 9 个周期发送 NACK，从机接收到 NACK，从机停止发送数据；</li></ul></li><li><p>数据位（小端模式）</p><ul><li>一帧数据一字节（8 位）</li><li>在 SCL 为高电平时，SDA 要保持稳定，此时数据有效。</li><li>SCL 为低电平时，可以改变 SDA</li></ul></li></ul><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/I2C%E6%95%B0%E6%8D%AE%E5%B8%A7%E8%A7%84%E5%88%99.png" class="" title="图1-8 I2C数据帧"><center> 图1-8 I2C数据帧 </center><ul><li>停止条件（如图 1-9 所示）<ul><li>先将 SDA 线由低电平拉至高电平</li><li>再将 SCL 线由高电平拉至低电平</li></ul></li></ul><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/I2C%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7.png" class="" title="图1-9 I2C开始与停止信号"><center> 图1-9 I2C开始与停止信号 </center><h3 id="i2c-协议帧"><a class="markdownIt-Anchor" href="#i2c-协议帧"></a> I2C 协议帧</h3><ul><li>7 位地址模式下的写操作协议帧:<br />首先发送起始信号 S，接着发送需要通信的 7 位从机地址，随机发送写指令，随后从机发送 ACK 信号；然后主机发送要传输的数据，从机接收到数据，返回 ACK；此时若主机不继续操作，则主机发送结束信号 P。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/7%E4%BD%8D%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E5%8D%8F%E8%AE%AE%E5%B8%A7.png" class="" title="图1-10 7位地址模式下的写操作协议帧"><center> 图1-10 7位地址模式下的写操作协议帧 </center></li><li>10 位地址模式下的写操作协议帧:<br />首先发送起始信号 S，接着发送需要通信的前 7 位从机地址，随机发送写指令，随后从机发送 ACK 信号，紧接着发送从机地址的剩下位，从机接收到回应 ACK 信号；然后主机发送要传输的数据，从机接收到数据，返回 ACK；此时若主机不继续操作，则主机发送结束信号 P。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/10%E4%BD%8D%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E5%8D%8F%E8%AE%AE%E5%B8%A7.png" class="" title="图1-11 10位地址模式下的写操作协议帧"><center> 图1-11 10位地址模式下的写操作协议帧 </center></li><li>7 位地址模式下的读操作协议帧：<br />首先发送起始信号 S，接着发送需要通信的 7 位从机地址，随机发送读指令，随后从机发送 ACK 信号；然后从机发送要传输的数据，主机接收到数据，返回 ACK；此时若主机不继续操作，则主机发送结束信号 P。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/7%E4%BD%8D%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%8D%8F%E8%AE%AE%E5%B8%A7.png" class="" title="图1-12 7位地址模式下的读操作协议帧"><center> 图1-12 7位地址模式下的读操作协议帧 </center></li><li>10 位地址模式下的读操作协议帧：<br />首先发送起始信号 S，接着发送需要通信的前 7 位从机地址，随机发送读指令，随后从机发送 ACK 信号，紧接着发送从机地址的剩下位，从机接收到回应 ACK 信号；然后从机发送要传输的数据，主机接收到数据，返回 ACK；此时若主机不继续操作，则主机发送结束信号 P。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/10%E4%BD%8D%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%8D%8F%E8%AE%AE%E5%B8%A7.png" class="" title="图1-13 10位地址模式下的读操作协议帧"><center> 图1-13 10位地址模式下的读操作协议帧 </center></li></ul><h3 id="i2c-的总线仲裁"><a class="markdownIt-Anchor" href="#i2c-的总线仲裁"></a> I2C 的总线仲裁</h3><ul><li><p>SCL 线的时钟同步：</p><ul><li>I2C 总线上具有<strong>与</strong>的逻辑功能，SCL 线上只要一个节点发送低电平，总线就保持低电平。当所有节点发送高电平时，总线才保持高电平。所以，时钟低电平的时间由时钟电平期最长的器件决定，而时钟的高电平时间由时钟高电平期最短的器件决定。</li><li>由于 I2C 这种特性，当多个主机同时发送时钟信号时，在总线上表示的是统一的时钟信号。如果从机希望主机降低传送速度可以通过将 SCL 主动拉低延长其低电平时间来通知主机，当主机在准备下一次传送时发现 SCL 的电平被拉低时进行等待，直到从机完成操作并释放 SCL 线的控制权。</li></ul></li><li><p>SDA 线上的仲裁</p><ul><li>SDA 线上的仲裁也是由于 I2C 总线具有线<strong>与</strong>的逻辑功能。主机在发送数据后，通过比较总线上的数据来决定是否退出竞争。丢失仲裁的主机立即切换到未被寻址的从机状态，以确保自身能被仲裁胜利的主机寻址到。仲裁失败的主机继续输出时钟脉冲（在 SCL 上），直到发送完当前的串行字节。通过这种原理可以保证 I2C 总线在多个主机企图控制总线时保证数据的不丢失。</li><li>解析:当多个设备想发送数据，对比数据低电平优先</li></ul></li></ul><h2 id="spi-通信协议"><a class="markdownIt-Anchor" href="#spi-通信协议"></a> SPI 通信协议</h2><h3 id="spi-的硬件连接"><a class="markdownIt-Anchor" href="#spi-的硬件连接"></a> SPI 的硬件连接</h3><p>如图 1-14 所示，SPI 硬件连接包含 SCK（时钟线）、MOSI（Master Output Slave Input，主输出从输入）、MISO（Master Input Slave Output，主输入从输出）、NSS（片选信号）。产生时钟的一侧称为主机，另一侧称为从机。总是只有一个主机（一般来说可以是微控制器/MCU），但是可以有多个从机。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/SPI%E7%89%A9%E7%90%86%E8%BF%9E%E6%8E%A5%E5%A4%9A%E8%AE%BE%E5%A4%87.svg" class="" title="图1-14 SPI物理连接"><center> 图1-14 SPI物理连接 </center>### SPI 的时序图<p>整体的传输过程分为如下几个过程：</p><ul><li>主机先将 NSS 信号拉低以确保从机接受数据；</li><li>当接收端检测到时钟的边沿信号时，它将立即读取数据线上的信号，这样就得到了一位数据（1bit）；</li><li>主机发送到从机时：主机产生相应的时钟信号，然后数据一位一位地将从 MOSI 信号线上进行发送到从机；</li><li>主机接收从机数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过 MISO 信号线发送。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/SPI%E6%97%B6%E5%BA%8F%E5%9B%BE.png" class="" title="图1-15 SPI时序图"><center> 图1-15 SPI时序图 </center></li></ul><h3 id="spi-数据帧"><a class="markdownIt-Anchor" href="#spi-数据帧"></a> SPI 数据帧</h3><ul><li><p>时钟频率：</p><ul><li><p>SPI 总线上的主机必须在通信开始时候配置并生成相应的时钟信号。在每个 SPI 时钟周期内，都会发生全双工数据传输。</p></li><li><p>主机在 MOSI 线上发送一位数据，从机读取它，而从机在 MISO 线上发送一位数据，主机读取它。</p></li><li><p>就算只进行单向的数据传输，也要保持这样的顺序。这就意味着无论接收任何数据，必须实际发送一些东西！在这种情况下，我们称其为虚拟数据；</p></li><li><p>从理论上讲，只要实际可行，时钟速率就可以是您想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的 SPI 传输速率。</p></li></ul></li><li><p>时钟极性（CKP/Clock Polarity）：时钟极性通常写为 CKP 或 CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据</p><ul><li>CKP = 0：时钟空闲 IDLE 为低电平 0；</li><li>CKP = 1：时钟空闲 IDLE 为高电平 1；</li></ul></li><li><p>时钟相位（CKE /Clock Phase (Edge)）：时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿</p><ul><li>CKE = 0：在时钟信号 SCK 的第一个跳变沿采样；</li><li>CKE = 1：在时钟信号 SCK 的第二个跳变沿采样；</li></ul></li><li><p>采集信号配置</p><table><thead><tr><th>SPI Mode</th><th>CPOL</th><th>CPHA</th><th>模式</th></tr></thead><tbody><tr><td>0 [00]</td><td>0</td><td>0</td><td>沿第一个上升沿采集信号</td></tr><tr><td>1 [01]</td><td>0</td><td>1</td><td>沿第一个下降沿采集信号</td></tr><tr><td>2 [10]</td><td>1</td><td>0</td><td>沿第二个下降沿采集信号</td></tr><tr><td>3 [11]</td><td>1</td><td>1</td><td>沿第二个上升沿采集信号</td></tr></tbody></table><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/SPI%E9%87%87%E9%9B%86%E4%BF%A1%E5%8F%B7%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE.png" class="" title="图1-16 SPI采集信号模式配置"><center> 图1-16 SPI采集信号模式配置 </center></li></ul><h2 id="can-通信协议"><a class="markdownIt-Anchor" href="#can-通信协议"></a> CAN 通信协议</h2><h3 id="can-总线物理连接"><a class="markdownIt-Anchor" href="#can-总线物理连接"></a> CAN 总线物理连接</h3><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E9%AB%98%E9%80%9FCAN%E6%80%BB%E7%BA%BF%EF%BC%88%E9%97%AD%E7%8E%AF%EF%BC%89.png" class="" title="高速CAN总线（闭环）"><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E4%BD%8E%E9%80%9FCAN%E6%80%BB%E7%BA%BF%EF%BC%88%E5%BC%80%E7%8E%AF%EF%BC%89.png" class="" title="高速CAN总线（开环）"><h3 id="can-总线特点"><a class="markdownIt-Anchor" href="#can-总线特点"></a> CAN 总线特点</h3><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">    <tr>        <td colspan="2" style="text-align: center;">物理层</td>        <td colspan="6" style="text-align: center;">ISO 11898(High Speed)</td>        <td colspan="6" style="text-align: center;">ISO 11519-2(Low Speed)</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">通信速度</td>        <td colspan="6"style="text-align: center;">40m/1Mbps</td>        <td colspan="6"style="text-align: center;">1km/40Kbps</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">总线最大长度</td>        <td colspan="6" style="text-align: center;">最大30</td>        <td colspan="6" style="text-align: center;">最大20</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">连接单元数</td>        <td colspan="3" style="text-align: center;">隐形</td>        <td colspan="3" style="text-align: center;">显形</td>        <td colspan="3" style="text-align: center;">隐形</td>        <td colspan="3" style="text-align: center;">显形</td>    </tr>    <tr>        <td rowspan="4" style="text-align: center;">总线拓扑</td>        <td style="text-align: center;"></td>        <td style="text-align: center;">Min</td>        <td style="text-align: center;">Nom</td>        <td style="text-align: center;">Max</td>        <td style="text-align: center;">Min</td>        <td style="text-align: center;">Nom</td>        <td style="text-align: center;">Max</td>        <td style="text-align: center;">Min</td>        <td style="text-align: center;">Nom</td>        <td style="text-align: center;">Max</td>        <td style="text-align: center;">Min</td>        <td style="text-align: center;">Nom</td>        <td style="text-align: center;">Max</td>    </tr>    <tr>        <td style="text-align: center;">CAN_High(V)</td>        <td style="text-align: center;">2.00</td>        <td style="text-align: center;">2.50</td>        <td style="text-align: center;">3.00</td>        <td style="text-align: center;">2.75</td>        <td style="text-align: center;">3.50</td>        <td style="text-align: center;">4.50</td>        <td style="text-align: center;">1.60</td>        <td style="text-align: center;">1.75</td>        <td style="text-align: center;">1.90</td>        <td style="text-align: center;">3.85</td>        <td style="text-align: center;">4.00</td>        <td style="text-align: center;">5.00</td>    </tr>    <tr>        <td style="text-align: center;">CAN_Low(V)</td>        <td style="text-align: center;">2.00</td>        <td style="text-align: center;">2.50</td>        <td style="text-align: center;">3.00</td>        <td style="text-align: center;">0.50</td>        <td style="text-align: center;">1.50</td>        <td style="text-align: center;">2.25</td>        <td style="text-align: center;">3.10</td>        <td style="text-align: center;">3.25</td>        <td style="text-align: center;">3.40</td>        <td style="text-align: center;">0.00</td>        <td style="text-align: center;">1.00</td>        <td style="text-align: center;">1.15</td>    </tr>    <tr>        <td style="text-align: center;">电位差 <br>(H-L) (V)</td>        <td style="text-align: center;">-0.5</td>        <td style="text-align: center;">0</td>        <td style="text-align: center;">0.05</td>        <td style="text-align: center;">1.5</td>        <td style="text-align: center;">2.0</td>        <td style="text-align: center;">3.0</td>        <td style="text-align: center;">-0.3</td>        <td style="text-align: center;">-1.5</td>        <td style="text-align: center;">-</td>        <td style="text-align: center;">0.3</td>        <td style="text-align: center;">3.0</td>        <td style="text-align: center;">-</td>    </tr>    <tr>        <td colspan="2" style="text-align: center;">特性</td>        <td colspan="6" style="text-align: center;">双绞线（屏蔽/非屏蔽）<br> 闭环总线 <br> 阻抗(Z)：120Ω(Min.85Ω Max.130Ω) <br>总线电阻率(r)：70mΩ/m <br>总线延迟时间：5ns/m 终端电阻：120Ω(Min.85Ω Max.130Ω)</td>        <td colspan="6" style="text-align: center;">双绞线（屏蔽/非屏蔽）<br> 开环总线 <br> 阻抗(Z)：120Ω(Min.85Ω Max.130Ω) <br>总线电阻率(r)：90mΩ/m <br>总线延迟时间：5ns/m 终端电阻：2.2KΩ(Min.2.09KΩ Max.2.31KΩ) <br>CAN_L与GND间静电容量 30pF/m <br>CAN_H与GND间静电容量 30pF/m</td>    </tr></table><ul><li><strong>多主机系统</strong>：<ul><li>在总线空闲时，所有的单元都可开始发送消息（多主控制）。</li><li>最先访问总线的单元可获得发送权（CSMA/CA 方式*1）。</li><li>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。</li></ul></li><li><strong>消息的发送/仲裁机制</strong>： CAN 协议中，所有的消息都以固定的格式发送。总线空闲时，所有与总线相连的单元都可以开始发送新消息。两个以上的单元同时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。</li><li><strong>系统的柔软性</strong>：与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。</li><li><strong>通信速度</strong>：根据整个网络的规模，可设定适合的通信速度。在同一网络中，所有单元必须设定成统一的通信速度。即使有一个单元的通信速度与其它的不一样，此单元也会输出错误信号，妨碍整个网络的通信。不同网络间则可以有不同的通信速度。</li><li>灵活性：CAN 协议灵活适应不同的应用场景，支持不同的波特率和通信速率。这使得 CAN 总线可以被广泛用于各种嵌入式系统，从低速的传感器网络到高速的汽车控制系统。</li><li><strong>远程数据请求</strong>：可通过发送“遥控帧” 请求其他单元发送数据。</li><li><strong>多种帧类型</strong>：CAN 总线上的节点没有地址的概念。CAN 总线上的数据是以帧为单位传输的，帧又分为数据帧、遥控帧等多种帧类型，帧包含需要传输的数据或控制信息。</li><li><strong>线与逻辑</strong>：CAN 总线具有“线与”的特性，也就是当由两个节点同时向总线发送信号时，一个是发送显性电平（逻辑 0），另一个发送隐性电平（逻辑 1），则总线呈现为显性电平。这个特性被用于总线总裁，也就是哪个节点优先占用总线进行发送操作。</li><li><strong>特定标识符</strong>：每一个帧有一个标识符（Identifier，一下简称 ID）。ID 不是地址，它表示传输数据的类型，也可以用于总线仲裁时确定优先级。例如，在汽车的 CAN 总线上，假设用于碰撞检测的节点输出数据帧 ID 为 01，车内温度检测节点发送数据帧的 ID 为 05 等。</li><li><strong>滤波特性</strong>：每个 CAN 节点都接收数据，但是可以对接收的帧根据 ID 进行过滤。只有节点需要的数据才会被接收并进一步处理，不需要的数据会被自动舍弃。例如，假设安全气囊控制器只接受碰撞检测节点发出的 ID 为 01 的帧，这种 ID 的过滤时有硬件完成的，以便安全气囊控制器在发送碰撞时能及时响应。</li><li><strong>错误检测功能·错误通知功能·错误恢复功能</strong>：<ul><li>所有的单元都可以检测错误（错误检测功能）。</li><li>检测出错误的单元会立即同时通知其他所有单元（错误通知功能）。</li><li>正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送<br />此消息直到成功发送为止（错误恢复功能）。</li></ul></li><li><strong>故障封闭</strong>：CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。</li><li><strong>连接</strong>：CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接<br />的单元数减少<br />注：CSMA/CA: Carrier Sense Multiple Access / Collision Avoidance</li></ul><h3 id="错误状态的种类"><a class="markdownIt-Anchor" href="#错误状态的种类"></a> 错误状态的种类</h3><h4 id="主动错误状态"><a class="markdownIt-Anchor" href="#主动错误状态"></a> 主动错误状态</h4><ul><li>主动错误状态是可以正常参加总线通信的状态。</li><li>处于主动错误状态的单元检测出错误时，输出主动错误标志。</li></ul><h4 id="被动错误状态"><a class="markdownIt-Anchor" href="#被动错误状态"></a> 被动错误状态</h4><ul><li>被动错误状态是易引起错误的状态。</li><li>处于被动错误状态的单元虽能参加总线通信，但为不妨碍其它单元通信，接收时不能积极地发送错误通知。</li><li>处于被动错误状态的单元即使检测出错误，而其它处于主动错误状态的单元如果没发现错误，整个总线也被认为是没有错误的。</li><li>处于被动错误状态的单元检测出错误时，输出被动错误标志。</li><li>另外，处于被动错误状态的单元在发送结束后不能马上再次开始发送。在开始下次发送前，在间隔帧期间内必须插入“延迟传送”(8 个位的隐性位)。</li></ul><h4 id="总线关闭状态"><a class="markdownIt-Anchor" href="#总线关闭状态"></a> 总线关闭状态</h4><ul><li>总线关闭态是不能参加总线上通信的状态。</li><li>信息的接收和发送均被禁止。</li><li>这些状态依靠发送错误计数和接收错误计数来管理，根据计数值决定进入何种状态。错误状态和计数值的关系如表 1 及图 4 所示。</li></ul><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">单元错误状态</td>      <td style="text-align: center;">发送错误计数值（TEC）</td>      <td style="text-align: center;">接收错误计数值（REC）</td>  </tr>  <tr>      <td style="text-align: center;">主动错误状态</td>      <td rowspan="2" style="text-align: center;">0~127 且 0~127</td>  </tr>  <tr>      <td style="text-align: center;">被动错误状态</td>      <td rowspan="2" style="text-align: center;">128~255 或 128~255</td>  </tr>  <tr>      <td style="text-align: center;">总线关闭状态</td>      <td rowspan="2" style="text-align: center;">256~  —— </td>  </tr></table><h4 id="错误计数值"><a class="markdownIt-Anchor" href="#错误计数值"></a> 错误计数值</h4><ul><li>发送错误计数值和接收错误计数值根据一定的条件发生变化。错误计数值的变动条件如表 2 所示。</li><li>一次数据的接收和发送可能同时满足多个条件。</li><li>错误计数器在错误标志的第一个位出现的时间点上开始计数。</li></ul><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;"> </td>      <td style="text-align: center;">接受和发送错误计数值的变动条件</td>      <td style="text-align: center;">发送错误计数值(TEC)</td>      <td style="text-align: center;">接收错误计数值(REC)</td>  </tr>  <tr>      <td style="text-align: center;">1</td>      <td style="text-align: center;">接收单元检测出错误时。<br>例外：接收单元在发送错误标志或过载标志中检测出“位错误”时，接收错误计数值不增加。</td>      <td style="text-align: center;"> —— </td>      <td style="text-align: center;"> +1 </td>  </tr>  <tr>      <td style="text-align: center;">2</td>      <td style="text-align: center;">接收单元在发送完错误标志后检测到的第一个位为显性电平时。</td>      <td style="text-align: center;"> —— </td>      <td style="text-align: center;"> +8 </td>  </tr>  <tr>      <td style="text-align: center;">3</td>      <td style="text-align: center;">发送单元在输出错误标志时。</td>      <td style="text-align: center;"> +8 </td>      <td style="text-align: center;"> —— </td>  </tr>  <tr>      <td style="text-align: center;">4</td>      <td style="text-align: center;">发送单元在发送主动错误标志或过载标志时，检测出位错误。</td>      <td style="text-align: center;"> +8 </td>      <td style="text-align: center;"> —— </td>  </tr>  <tr>      <td style="text-align: center;">5</td>      <td style="text-align: center;">接收单元在发送主动错误标志或过载标志时，检测出位错误。</td>      <td style="text-align: center;"> —— </td>      <td style="text-align: center;"> +8 </td>  </tr>  <tr>      <td style="text-align: center;">6</td>      <td style="text-align: center;">各单元从主动错误标志、过载标志的最开始检测出连续 14个位的显性位时。之后，每检测出连续的 8 个位的显性位时。</td>      <td style="text-align: center;"> 发送时+8 </td>      <td style="text-align: center;"> 接收时+8 </td>  </tr>  <tr>      <td style="text-align: center;">7</td>      <td style="text-align: center;">检测出在被动错误标志后追加的连续 8 个位的显性位时。</td>      <td style="text-align: center;"> 发送时+8 </td>      <td style="text-align: center;"> 接收时+8 </td>  </tr>  <tr>      <td style="text-align: center;">8</td>      <td style="text-align: center;">发送单元正常发送数据结束时（返回 ACK 且到帧结束也未检测出错误时）。</td>      <td style="text-align: center;"> −1 <br>TEC=0 时±0 </td>      <td style="text-align: center;"> —— </td>  </tr>  <tr>      <td style="text-align: center;">9</td>      <td style="text-align: center;">接收单元正常接收数据结束时（到 CRC 未检测出错误且正常返回 ACK 时）。</td>      <td style="text-align: center;"> —— </td>      <td style="text-align: center;"> 1≤REC≤127 时-1 <br> REC=0 时±0 <br> REC>127 时 设 REC=127 </td>  </tr>    <tr>      <td style="text-align: center;">10</td>      <td style="text-align: center;">处于总线关闭态的单元，检测到 128 次连续 11 个位的隐性位。</td>      <td style="text-align: center;"> TEC=0 </td>      <td style="text-align: center;"> REC=0 </td>  </tr></table><h3 id="can-总线协议帧"><a class="markdownIt-Anchor" href="#can-总线协议帧"></a> CAN 总线协议帧</h3><h4 id="can-网络通信包括五种帧"><a class="markdownIt-Anchor" href="#can-网络通信包括五种帧"></a> CAN 网络通信包括五种帧：</h4><table><thead><tr><th>帧类型</th><th>帧用途</th></tr></thead><tbody><tr><td>数据帧（Data frame）</td><td>节点发送的包含 ID 和数据的帧，用于发送单元向接收单元传送数据的帧</td></tr><tr><td>遥控帧（Remote frame）</td><td>节点向网络上的其他节点发出的某个 ID 的数据请求，发送节点收到遥控帧后就可以发送相应 ID 的数据帧</td></tr><tr><td>错误帧（Error frame）</td><td>节点检测出错误时，向其他节点发送的通知错误的帧</td></tr><tr><td>过载帧（Overload frame）</td><td>接收单元未做好接收数据的准备时发送的帧，发送节点收到过载帧后暂缓发送数据帧</td></tr><tr><td>帧间空间（Inter-frame space）</td><td>用于将数据帧、遥控帧与前后帧分隔开的帧</td></tr></tbody></table><h4 id="can-协议数据帧"><a class="markdownIt-Anchor" href="#can-协议数据帧"></a> CAN 协议数据帧</h4><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E5%B8%A7.svg" class="" title="CAN总线标准数据帧"><p>图 CAN 总线标准数据帧</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E5%B8%A7.svg" class="" title="CAN总线扩展数据帧"><ul><li><p>数据帧由七个段构成（如上图）</p><ul><li><p>帧起始（SOF） ：表示数据开始的段，占一位，显形电平有效。</p></li><li><p>仲裁段：表示该帧优先的段</p><ul><li>标准帧：由 11 位的 ID 和 RTR 构成</li><li>扩展帧：在 11 位 ID 的基础上，扩展 18 位，和 SRR 和 IDE 构成</li><li>注：标准帧的 ID 从 ID28 到 ID18 依次发送，禁止高七位为隐形，即 ID=1111 111X XXX<br />扩展帧 29 位，同样禁止高七位为隐形即 ID=1111 111X XXX</li></ul></li><li><p>控制段：表示数据的字节数和保留位的段，由 6 个位构成</p><ul><li><p>标准帧：IDE+r0+DLC</p></li><li><p>扩展帧：r1+r0+DLC</p></li><li><p>（注）保留位（r0、r1）：必须全部以显形电平发送，但接受法可以接受显形、隐形以及任何组合的电平</p></li><li><p>（注）数据长度码（DLC）：数据长度码与数据的字节数如下表所示，其中数据的字节数必须为 0~8 字节。但接收方对 DLC=9~15 并不视为错误</p><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto"><tr>    <td rowspan="2" style="text-align: center;">数据字节数</td>    <td colspan="4" style="text-align: center;">数据长度码</td></tr><tr>    <td style="text-align: center;">DLC3</td>    <td style="text-align: center;">DLC2</td>    <td style="text-align: center;">DLC1</td>    <td style="text-align: center;">DLC0</td></tr><tr>    <td style="text-align: center;">0</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td></tr><tr>    <td style="text-align: center;">1</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td></tr><tr>    <td style="text-align: center;">2</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">D</td></tr><tr>    <td style="text-align: center;">3</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">R</td></tr><tr>    <td style="text-align: center;">4</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td></tr><tr>    <td style="text-align: center;">5</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td></tr><tr>    <td style="text-align: center;">6</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">D</td></tr><tr>    <td style="text-align: center;">7</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">R</td></tr><tr>    <td style="text-align: center;">8</td>    <td style="text-align: center;">R</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td>    <td style="text-align: center;">D</td></tr></li></ul></table>注：D为显形电平；R为隐形电平  - 数据段：数据的内容，可以发送0~8字节的数据，从MSB开始传输  - CRC：纠错段，由15个位的CRC顺序和1个位的CRC界定符（用于分隔的位）构成    - 注：CRC根据多项式生成的CRC值，CRC的计算范围包括帧起始、仲裁段、控制段、数据段。接收方以相同的算法计算CRC值并进行比较，不一致时会报错  - ACK段：表示确认正常接收的段，由ACK槽（ACK Slot）和ACK界定符构成    - 发送单元的ACK段：发送2个隐性位    - 接收单元的ACK段：接收到正确消息的单元子啊ACK槽（ACK Slot）发送显性位，通知发送单元正常接收结束    - 发送ACK：发送 ACK 的是在既不处于总线关闭态也不处于休眠态的所有接收单元中，接收到正常消息的单元（发送单元不发送 ACK）。所谓正常消息是指不含填充错误、格式错误、CRC 错误的消息。  - 帧结束：表示数据帧结束的段，由7个隐性位构成</li></ul></li><li><p>备注：</p><ul><li>总线上有显形电平“0”和隐形电平“1”；</li><li>总线上执行逻辑“与”，因此显形电平具有“优先”权；</li></ul></li></ul><h4 id="can-总线遥控帧"><a class="markdownIt-Anchor" href="#can-总线遥控帧"></a> CAN 总线遥控帧：</h4><p>接收单元向发送单元请求发送数据所用的帧。遥控帧由 6 个段组成。遥控帧没有数据帧的数据段。</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86%E8%BF%9C%E7%A8%8B%E5%B8%A7.svg" class="" title="CAN总线标准遥控帧"><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E6%89%A9%E5%B1%95%E8%BF%9C%E7%A8%8B%E5%B8%A7.svg" class="" title="CAN总线扩展遥控帧"><ul><li>帧起始（SOF）：表示帧开始的段</li><li>仲裁段：表示该帧优先级的段。可请求具有相同 ID 的数据帧</li><li>控制段：表示数据的字节数及保留位的段</li><li>CRC 段：检查帧的传输错误的段</li><li>ACK 段：表示确认正常接收的段</li><li>帧结束：表示遥控帧结束的段</li><li>注：<ul><li>遥控帧相比于数据帧，没有数据段且 RTR 位为隐性</li><li>遥控帧没有数据段，数据长度码该如何表示：遥控帧的数据长度码以所请求数据帧的数据长度码表示</li><li>没有数据段的数据帧有何用途：可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下</li></ul></li></ul><h4 id="can-总线错误帧"><a class="markdownIt-Anchor" href="#can-总线错误帧"></a> CAN 总线错误帧：</h4><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E9%94%99%E8%AF%AF%E5%B8%A7.svg" class="" title="CAN总线错误帧"><p>用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。</p><ul><li>错误标志<ul><li>主动错误标志：处于主动错误状态的单元检测出错误时，输出的错误标志，由 6 个位的显性位构成</li><li>被动错误标志：处于被动错误状态的单元检测出错误时输出的错误标志，由 6 个位的隐性位构成</li></ul></li><li>错误界定符：由 8 个位的隐性位构成</li></ul><h4 id="can-总线过载帧"><a class="markdownIt-Anchor" href="#can-总线过载帧"></a> CAN 总线过载帧：</h4><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E8%BF%87%E8%BD%BD%E5%B8%A7.svg" class="" title="CAN总线过载帧"><p>过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。</p><ul><li>过载标志：与主动错误标志构成相同，6 个位的显性位</li><li>过载界定符：过载界定符的构成与错误界定符的构成相同，8 个位的隐性位构成</li></ul><h4 id="can-总线间隔帧"><a class="markdownIt-Anchor" href="#can-总线间隔帧"></a> CAN 总线间隔帧</h4><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/CAN%E6%80%BB%E7%BA%BF%E9%97%B4%E9%9A%94%E5%B8%A7.svg" class="" title="CAN总线间隔帧"><p>帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开</p><ul><li>间隔：3 个隐性位</li><li>总线空闲：隐性电平，长度不限，此状态下，可视为总线空闲，要发送的单元开始访问总线</li><li>延迟传送（发送暂时停止）：8 个位的隐性位，只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段</li></ul><h3 id="can-总线同步及总线仲裁"><a class="markdownIt-Anchor" href="#can-总线同步及总线仲裁"></a> CAN 总线同步及总线仲裁</h3><ul><li>数据帧和遥控帧的优先级：具有显性 ID 的帧具有优先权，若具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权</li><li>标准格式和扩展格式的优先级：标准格式 ID 与具有相同 ID 的遥控帧或扩展格式的数据帧在总线竞争时，标准格式的 RTR 位为显形具有优先权。</li></ul><h4 id="位填充位填充是为了防止突发错误而设定的功能-当同样的电平持续-5-位时则添加一个位的反型数据"><a class="markdownIt-Anchor" href="#位填充位填充是为了防止突发错误而设定的功能-当同样的电平持续-5-位时则添加一个位的反型数据"></a> 位填充：位填充是为了防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据</h4><pre><code>- 发送单元的工作：在发送数据帧和遥控帧时，SOF~CRC段间的数据，相同电平如果持续5位，在下一个位（第6位）要插入1位与前5位相反的电平- 接收单元的工作：在接受数据帧和遥控帧时，SOF~CRC段间的数据，相同电平如果持续5位，需要删除下一个位（第6位）再接收。如果这个第6个位的电平与前5位相同，将被视为错误并发送错误帧。</code></pre><h5 id="错误的种类5-种位错误-填充错误-crc-错误-格式错误-ack-错误"><a class="markdownIt-Anchor" href="#错误的种类5-种位错误-填充错误-crc-错误-格式错误-ack-错误"></a> 错误的种类（5 种）：位错误、填充错误、CRC 错误、格式错误、ACK 错误</h5><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">错误的种类</td>      <td style="text-align: center;">错误的内容</td>      <td style="text-align: center;">错误的检测帧（段）</td>      <td style="text-align: center;">检测单元</td>  </tr>  <tr>      <td style="text-align: center;">位错误</td>      <td style="text-align: center;">比较输出电平和总线电平（不含填充位），当两电平不一样时所检测到的错误</td>      <td style="text-align: center;">数据帧（SOF~EOF）<br>遥控帧（SOF~EOF）<br>错误帧<br>过载帧</td>      <td style="text-align: center;">发送单元<br>接收单元</td>  </tr>  <tr>      <td style="text-align: center;">填充错误</td>      <td style="text-align: center;">在需要位填充的段内，连续检测到6位相同的电平时所检测到的错误</td>      <td style="text-align: center;">数据帧（SOF~CRC顺序）<br>遥控帧（SOF~CRC顺序）</td>      <td style="text-align: center;">发送单元<br>接收单元</td>  </tr>  <tr>      <td style="text-align: center;">格式错误</td>      <td style="text-align: center;">检测出与固定格式的位段相反的格式时所检测到的错误</td>      <td style="text-align: center;">数据帧（CRC界定符、ACK界定符、EOF）<br>遥控帧（CRC界定符、ACK界定符、EOF）<br>错误界定符<br>过载界定符</td>      <td style="text-align: center;">接收单元</td>  </tr>  <tr>      <td style="text-align: center;">ACK错误</td>      <td style="text-align: center;">发送单元在ACK槽（ACK Slot）中检测出隐性电平时所检测到的错误（ACK没有被传送过来时所检测到的错误）</td>      <td style="text-align: center;">数据帧（ACK槽）<br>遥控帧（ACK槽）<br>错误界定符<br>过载界定符</td>      <td style="text-align: center;">发送单元</td>  </tr></table><ul><li>位错误<ul><li>位错误由向总线上输出数据帧、遥控帧、错误帧、过载帧的单元和输出ACK的单元、输出错误的单元来检测；</li><li>在仲裁段输出隐性电平，但检测出显形电平时，将被视为仲裁失利，而不是位错误；</li><li>在仲裁段作为填充位输出隐性电平时，但检测出显性电平时，将不视为位错误，而是填充错误；</li><li>发送单元在ACK段输出隐性电平，但检测出显性电平时，将判断为其它单元的ACK应答，而非位错误；</li><li>输出被动错误标志（6个隐性位）但检测出为显性电平时，将遵从错误标志的结束条件，等待检测出连续相同6个位的值（显性或隐性），但不视为位错误；</li></ul></li><li>格式错误<ul><li>即使接收到单元检测出EOF（7个位的隐性位）的最后一位（第8位）为显性电平，也不视为格式错误；</li><li>即使接收单元检测出数据长度码（DLC）中的9~15的值时，也不视为格式错误；</li></ul></li></ul><h4 id="错误帧的输出"><a class="markdownIt-Anchor" href="#错误帧的输出"></a> 错误帧的输出</h4><ul><li>检测出满足错误条件的单元输出错误标志通报错误</li><li>处于主动错误状态的单元输出的错误标志为主动错误标志；处于被动错误状态的单元输出的错误标志为被动错误标志</li><li>发送单元发送完错误帧后，将再次发生那个数据帧或遥控帧<br />错误标志输出时序表如下：</li></ul><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">错误的种类</td>      <td style="text-align: center;">输出时序</td>  </tr>  <tr>      <td style="text-align: center;">位错误</td>      <td rowspan="4" style="text-align: center;">从检测出错误后的下一位开始传输出错误标志</td>  </tr>  <tr>      <td style="text-align: center;">填充错误</td>  </tr>  <tr>      <td style="text-align: center;">格式错误</td>  </tr>  <tr>      <td style="text-align: center;">ACK错误</td>  </tr>  <tr>      <td style="text-align: center;">CRC错误</td>      <td style="text-align: center;">ACK界定符后的下一位开始输出错误标志</td>  </tr></table><h4 id="位时序"><a class="markdownIt-Anchor" href="#位时序"></a> 位时序</h4><p>由发送单元在非同步的情况下发送每秒钟的位数称为位速率。一个位可以分成 4 段：同步段（SS）、传播时间段（PTS）、相位缓冲段 1（PBS1）、相位缓冲段 2（PBS2）<br />这些段由称为 TimeQuantum（简称 Tq）的最小单位构成：1 位分为 4 段，每个段又由若干个 Tq 构成，称为位时序。1 位由多少段 Tq 构成，每个段由多少个 Tq 构成，可以任意设定时序，通过设定位时序，多个单元可<br />同时采样，也可任意设定采样点。各段的作用和 Tq 数据表如下表所示：</p><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">段名称</td>      <td style="text-align: center;">段作用</td>      <td colspan="2"style="text-align: center;">Tq数</td>  </tr>  <tr>      <td style="text-align: center;">同步段（SS：Synchronization Segment）</td>      <td style="text-align: center;">多个连接在总线上的单元通过此段实现时序调整，同步进行接收和发送的工作。由隐性电平到显性电平的边沿或由显性电平到隐性电平边沿最好出现在此段中。</td>      <td style="text-align: center;">1Tq</td>      <td rowspan="4" style="text-align: center;">8~25Tq</td>  </tr>  <tr>      <td style="text-align: center;">传播时间段（PTS：Propagation Time Segment）</td>      <td style="text-align: center;">用于吸收网络上的物理延迟的段。所谓的网络的物理延迟指发送单元的输出延迟、总线上信号的传播延迟、接收单元的输入延迟。这个段的时间为以上各延迟时间的和的两倍。</td>      <td style="text-align: center;">1~8Tq</td>  </tr>  <tr>      <td style="text-align: center;">相位缓冲段1</td>      <td rowspan="2" style="text-align: center;">当信号边沿不能被包含于 SS 段中时，可在此段进行补偿。<br>由于各单元以各自独立的时钟工作，细微的时钟误差会累积起来，PBS 段可用于吸收此误差。<br>通过对相位缓冲段加减 SJW 吸收误差。（请参照图 34）。SJW 加大后允许误差加大，但通信速度下降。</td>      <td style="text-align: center;">1~8Tq</td>  </tr>  <tr>      <td style="text-align: center;">相位缓冲段2</td>      <td style="text-align: center;">2~8Tq</td>  </tr>    <tr>      <td style="text-align: center;">再用步补偿宽度</td>      <td style="text-align: center;">因时钟频率偏差、传送延迟等，各单元有同步误差。SJW 为补偿此误差的最大值。</td>      <td colspan="2" sstyle="text-align: center;">1~4Tq</td>  </tr></table><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/1bit=10Tq.svg" class="" title="1bit&#x3D;10Tq"><p>注：所谓采样点是读取总线电平，并将读到的电平作为位值的点。位置在 PBS1 结束处</p><h4 id="取得同步的方法"><a class="markdownIt-Anchor" href="#取得同步的方法"></a> 取得同步的方法</h4><p>CAN 总线协议的通信方法位 NRZ（Non-Return to Zero）的方式。各个位的开头或结尾都没有附加同步信号。发送单元与位时序同步的方式开始发送数据。另外，接收单元根据总线上电平变化进行同步并进行接收工作。但是，发送单元和接收单元存在的时钟频率误差以及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收单元通过硬件或者再同步的方法调整时序进行接收。</p><ul><li>硬件再同步：接收单元在总线空闲状态检测出帧起始时进行的同步调整，在检测出边沿的地方不考虑 SJW 的值而认为是 SS 段，如下图所示。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5.svg" class="" title="硬件同步"></li><li>再同步：在接收过程中检测出总线电平上的电平变化时进行的同步调整，每当检测出边沿时，根据 SJW 的值通过加长 PBS1 段、或缩短 PBS2 段，以调整同步。但如果发生了超出 SJW 值的误差时，最大调整量不能超过 SJW 值。<img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%86%8D%E5%90%8C%E6%AD%A5.svg" class="" title="再同步"></li><li>调整同步（硬件同步和再同步）的规则：<ul><li>1 个位中只进行一次同步调整</li><li>只有当上次采样点的总线值和边沿后的值不同时，该边沿才能用于调整同步。</li><li>在总线空闲且存在隐性电平到显性电平的边沿时，则一定要进行硬件同步</li><li>在总线非空闲时检测到的隐性电平到显性电平的边沿如果满足条件（1）和（2），将进行再同步。但还要满足下满条件：<ul><li>发送单元观测到自身输出的显性电平有延时不进行再同步</li><li>发送单元在帧起始到仲裁段有多个单元同时发送的情况下，对延迟边沿不进行再同步</li></ul></li></ul></li></ul><h2 id="以太网通信"><a class="markdownIt-Anchor" href="#以太网通信"></a> 以太网通信</h2><p>以太网分类</p><ul><li>标准以太网：10Mbit/s</li><li>快速以太网：100Mbit/s</li><li>千兆以太网：1000Mbit/s</li><li>万兆以太网：10Gbit/s</li></ul><h4 id="百兆网口和千兆网口线序"><a class="markdownIt-Anchor" href="#百兆网口和千兆网口线序"></a> 百兆网口和千兆网口线序</h4><p>RJ45 接口定义：</p><ul><li>百兆网口线序</li></ul><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">引脚编号</td>      <td style="text-align: center;">名字</td>      <td style="text-align: center;">功能说明</td>  </tr>  <tr>      <td style="text-align: center;">1</td>      <td style="text-align: center;">TX+</td>      <td style="text-align: center;">Tranceive Data+（发信号+）</td>  </tr>  <tr>      <td style="text-align: center;">2</td>      <td style="text-align: center;">TX-</td>      <td style="text-align: center;">Tranceive Data-（发信号-）</td>  </tr>  <tr>      <td style="text-align: center;">3</td>      <td style="text-align: center;">RX+</td>      <td style="text-align: center;">Receive Data+（收信号+）</td>  </tr>  <tr>      <td style="text-align: center;">4</td>      <td style="text-align: center;">NC</td>      <td style="text-align: center;">Not connected (空脚)</td>  </tr>  <tr>      <td style="text-align: center;">5</td>      <td style="text-align: center;">NC</td>      <td style="text-align: center;">Not connected (空脚)</td>  </tr>  <tr>      <td style="text-align: center;">6</td>      <td style="text-align: center;">RX-</td>      <td style="text-align: center;">Receive Data-(收信号-)</td>  </tr>  <tr>      <td style="text-align: center;">7</td>      <td style="text-align: center;">NC</td>      <td style="text-align: center;">Not connected (空脚)</td>  </tr>  <tr>      <td style="text-align: center;">8</td>      <td style="text-align: center;">NC</td>      <td style="text-align: center;">Not connected (空脚)</td>  </tr></table><ul><li>千兆网口线序</li></ul><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">引脚编号</td>      <td style="text-align: center;">名字</td>      <td style="text-align: center;">功能说明</td>  </tr>  <tr>      <td style="text-align: center;">1</td>      <td style="text-align: center;">TX_D1+</td>      <td style="text-align: center;">Tranceive Data1+（发信号+）</td>  </tr>  <tr>      <td style="text-align: center;">2</td>      <td style="text-align: center;">TX_D1-</td>      <td style="text-align: center;">Tranceive Data1-（发信号-）</td>  </tr>  <tr>      <td style="text-align: center;">3</td>      <td style="text-align: center;">RX_D2+</td>      <td style="text-align: center;">Receive Data2+（收信号+）</td>  </tr>  <tr>      <td style="text-align: center;">4</td>      <td style="text-align: center;">BI_D3+</td>      <td style="text-align: center;">Bi-directional Data3+ (双向信号传输)</td>  </tr>  <tr>      <td style="text-align: center;">5</td>      <td style="text-align: center;">BI_D3-</td>      <td style="text-align: center;">Bi-directional Data3- (双向信号传输)</td>  </tr>  <tr>      <td style="text-align: center;">6</td>      <td style="text-align: center;">RX_D2-</td>      <td style="text-align: center;">Receive Data2-(收信号-)</td>  </tr>  <tr>      <td style="text-align: center;">7</td>      <td style="text-align: center;">BI_D4+</td>      <td style="text-align: center;">Bi-directional Data4+ (双向信号传输)</td>  </tr>  <tr>      <td style="text-align: center;">8</td>      <td style="text-align: center;">BI_D4-</td>      <td style="text-align: center;">Bi-directional Data4- (双向信号传输)</td>  </tr></table><h4 id="osi-模型与-tcpip-模型"><a class="markdownIt-Anchor" href="#osi-模型与-tcpip-模型"></a> OSI 模型与 TCP/IP 模型</h4><table border="1" cellpadding="3" cellspacing="0" style="width: 100%;margin:auto">  <tr>      <td style="text-align: center;">OSI参考模型</td>      <td style="text-align: center;">含义</td>      <td style="text-align: center;">协议栈</td>      <td style="text-align: center;">物理设备</td>      <td style="text-align: center;">TCP/IP五层模型</td>  </tr>  <tr>      <td style="text-align: center;">应用层</td>      <td style="text-align: center;">为应用程序提供服务</td>      <td rowspan="3" style="text-align: center;">HTTP  Telnet  FTP  TFTP  DNS  SMTP </td>      <td rowspan="3" style="text-align: center;">——</td>      <td rowspan="3" style="text-align: center;">应用层</td>  </tr>  <tr>      <td style="text-align: center;">表示层</td>      <td style="text-align: center;">数据格式化转化、数据加密</td>  </tr>  <tr>      <td style="text-align: center;">会话层</td>      <td style="text-align: center;">建立、管理和维护会话</td>  </tr>  <tr>      <td style="text-align: center;">传输层</td>      <td style="text-align: center;">建立、管理和维护端到端的连接</td>      <td style="text-align: center;">TCP  UDP</td>      <td style="text-align: center;">四层交换机、四层路由器</td>      <td style="text-align: center;">传输层</td>  </tr>  <tr>      <td style="text-align: center;">网络层</td>      <td style="text-align: center;">IP选址及路由选择</td>      <td style="text-align: center;">IP  ICMP  RIP  IGMP</td>      <td style="text-align: center;">路由器、三层交换机</td>      <td style="text-align: center;">网络层</td>  </tr>  <tr>      <td style="text-align: center;">数据链路层</td>      <td style="text-align: center;">提供介质访问和链路管理</td>      <td style="text-align: center;">ARP  RARP  IEEE802.3  PPP  CSMA/CD</td>      <td style="text-align: center;">网桥、以太网交换机、网卡</td>      <td style="text-align: center;">数据链路层</td>  </tr>  <tr>      <td style="text-align: center;">物理层</td>      <td style="text-align: center;">物理层</td>      <td style="text-align: center;">FE自协商  Manchester  MLT-3  4A  PAM5</td>      <td style="text-align: center;">中继器、集线器、双绞线</td>      <td style="text-align: center;">物理层</td>  </tr></table><h3 id="以太网数据构成"><a class="markdownIt-Anchor" href="#以太网数据构成"></a> 以太网数据构成</h3><p>以太网数据帧构成如下图所示：</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%8C%85.png" class="" title="以太网数据包"><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class="" title="以太网帧格式"><ul><li>前导码（Preamble）：为实现地政数据的正确阐述，物理层使用 7 个字节同步码（0/1 交替&lt;==&gt;55-55-55-55-55-55-55）实现数据同步；</li><li>帧起始界定符（Start Frame Delimiter, SFD）：使用一个字节的 SFD（固定值为 0xd5）来表示一帧的开始，即后面紧跟着传输的就是以太网的帧头；</li><li>目的 MAC 地址：即接受的物理 MAC 地址，占用 6 字节。MAC 地址从应用上可分为单播地址、组播地址和广播地址。<ul><li>单播地址：第一个字节最低位为 0，比如 00-00-00-11-11-11，一般用于标志唯一的设备</li><li>组播地址：第一个字节最低位为 1，比如 01-00-00-11-11-11，一般用于标志同属一组的多个设备</li><li>广播地址：所有位皆为 1，即 FF-FF-FF-FF-FF-FF，用于标志同一网段中的所有设备</li></ul></li><li>源 MAC 地址：即发送端的 MAC 的物理地址，占 6 字节；</li><li>长度/类型：长度/类型占 2 字节，当两字节的值小于 1536（十六进制为 0x0600）时，表示该以太网中的数据段长度；如果这两字节大于 1536，则表示该以太网中的数据属于哪个上层协议，如 0x800 标识 IP 协议（网关协议）、0x0806 表示 ARP 协议（地址解析协议）等；</li><li>数据：以太网中的数据段长度最小 46 个字节，最大 1500 个字节。最大值 1500 称为以太网的最大传输单元（MTU，Maximum Transmission Unit），之所以限制最大传输单元是因为在多个计算机的数据帧排队等待传输时，如果某个数据帧太大的话，那么其它数据帧等待的时间就会加长，导致体验变差，这就像一个十字路口的红绿灯，你可以让绿灯持续亮一小时，但是等红灯的人一定不愿意的。另外还要考虑网络 I/O 控制器缓存区资源以及网络最大的承载能力等因素，因此最大传输单元是由各种综合因素决定的。为了避免增加额外的配置，通常以太网的有效数据字段小于 1500 个字节。</li><li>帧检验序列（Frame Check Sequence, FCS）:为了确保数据的正确传输，在数据尾部加入了 4 字节的循环冗余校验码（CRC 校验）来检测数据是否传输错误。CRC 数据校验从以太网帧头开始即不含前导码和帧起始界定符。通用 CRC 标准有 CRC-8、CRC-16、CRC-32、CRC-CCIT，其中在网络通信系统中应用最广泛的是 CRC-32 标准；</li></ul><h3 id="ip-协议构成"><a class="markdownIt-Anchor" href="#ip-协议构成"></a> IP 协议构成</h3><p>IP 协议是 TCP/IP 协议栈中的核心，IP 协议规定了数据传输的基本单元和格式。IP 协议位于以太网 MAC 帧格式的数据段，IP 协议内容是由 IP 首部和数据字段组成。TCP、UDP 以及 ICMP 数据都以 IP 数据保温传输</p><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/IP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" class="" title="IP报文格式"><p>注：前 20 个字节是固定字节，后面是可选字段</p><ul><li>版本：4 位 IP 版本号（Version），这个值设置为 b0100 表示 IPv4，设置为 b0110 时表示 IPv6；</li><li>首部长度：4 位首部长度（Internet Header Length, IHL），表示 IP 首部一共有多少个 32 位（4 个字节）。在没有可选字段，IP 首部长度为 20 个字节，因此首部长度为 5；</li><li>服务类型：8 位服务类型（Type of service, TOP），该字段被划分成两个子字段：3 位优先级字段（现在已经基本忽略掉了）和 4 位 TOS 字段，最后一位固定为 0。服务类型为 0 时表示一般服务。</li><li>总长度：16 位 IP 数据报总长度（Total Length），包括 IP 首部和 IP 数据部分，以字节为单位。我们利用 IP 首部长度和 IP 数据报总长度，就可以知道 IP 数据报中数据内容的起始位置和长度。由于该字段长 16bit，所以 IP 数据报最长可达 65535 字节。尽管理论上可以传输长达 65535 字节的 IP 数据报，但实际上还要考虑网络的最大承载能力等因素；</li><li>标识字段：16 位标识（Identification）字段，用来标识主机发送的每一份数据报。通常每发送一份报文它的值就会加 1；</li><li>3 位标志（Flags）字段，第 1 位为保留位；第 2 位表示禁止分片（1 表示不分片 0：允许分片）；第 3 位标识更多分片（除了数据报的最后一个分片外，其它分片都为 1）；</li><li>片偏移：13 位片偏移（Fragment Offset），在接收方进行数据报重组时用来标识分片的顺序；</li><li>生存时间：8 位生存时间字段，TTL（Time To Live）域防止丢失的数据包在无休止的传播，一般被设置为 64 或者 128；</li><li>协议：8 位协议（Protocol）类型，表示此数据报所携带上层数据使用的协议类型，ICMP 为 1，TCP 为 6，UDP 为 17；</li><li>首部校验和：16 位首部校验和（Header Checksum），该字段只校验数据报的首部，不包含数据部分；校验 IP 数据报头部是否被破坏、篡改和丢失等；</li><li>源 IP 地址：32 位源 IP 地址（Source Address），即发送端的 IP 地址，如 192.168.1.123；</li><li>目的 IP 地址：32 位目的 IP 地址（Destination Address），即接收端的 IP 地址，如<br />192.168.1.102</li><li>可选字段：是数据报中的一个可变长度的可选信息，选项字段以 32bit 为界，不足时插入值为 0 的填充字节，保证 IP 首部始终是 32bit 的整数倍</li></ul><h3 id="tcp-udp-协议区别"><a class="markdownIt-Anchor" href="#tcp-udp-协议区别"></a> TCP || UDP 协议区别</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠</td><td>传输不可靠</td></tr><tr><td>传输效率低</td><td>传输效率高</td></tr><tr><td>占用资源多</td><td>占用资源少</td></tr><tr><td>浏览器、QQ 传输文件</td><td>QQ 语音、视频</td></tr></tbody></table><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/UDP%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class="" title="UDP协议数据帧格式"><ul><li>源端口号：16 位发送端端口号，用于区分不同服务的端口，端口号范围 0~65535；</li><li>目的端口号：16 位接收端端口号；</li><li>UDP 长度：16 位 UDP 长度，包含 UDP 首部长度+数据长度，单位是字节（Byte）；</li><li>UDP 校验和：16 位 UDP 校验和。UDP 计算校验和的方法和计算 IP 数据报首部校验和的方法相似，但不同的是 IP 数据报的校验和只检验 IP 数据报的首部，而 UDP 校验和包含三个部分：UDP 伪首部，UDP 首部和 UDP 的数据部分。伪首部的数据是从 IP 数据报头和 UDP 数据报头获取的，包括源 IP 地址，目的 IP 地址，协议类型和 UDP 长度，其目的是让 UDP 两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。在大多数使用场景中接收端并不检测 UDP 校验和，因此这里不做过多介绍。</li></ul><img src="/2024/07/18/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/TCP%E5%8D%8F%E8%AE%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class="" title="TCP协议帧格式"><ul><li>源端口：16 位发送端端口号，用于区分不同服务的端口，由基于 TCP 应用程序的用户进程随机选择</li><li>目的端口：2 个字节，指明接收者所用的端口号，一般由应用程序来指定</li><li>顺序号：4 个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数，序号是 32 bit 的无符号数，序号达到 2^32-1 后又从 0 开始。比如我们收到一个数据报中 sq(顺序号) =0，数据报内容为 20 字节，那么下一个数据报的 sq 就应该是 21。当建立一个新的连接时，SYN 标志变为 1，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN</li><li>确认顺序：4 个字节，包含发送确认的一端所期待收到的下一个顺序号。因此，确认序号应该是上次已经成功收到数据字节顺序号加 1 。比如我们收到的一个数据报的 sq = 0 ，数据报内容为 20 字节，那么我们的 ack(确认序号) 应该是 21 ，用来表明 sq=0 ，内容为 20 字节的数据报已经收到，接下来期望收到的是 sq=21 的数据报。只有 ACK 标志为 1 时确认序号字段才有效</li><li>首部长度：4 位，给出报头中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的，这个字段占 4 bit，即 TCP 最多有 60 (15*4) 字节的首部</li><li>保留区：6 位，保留给将来使用，目前必须置为 0</li><li>控制位：<ul><li>URG：1 表示紧急指针有效，0 表示忽略紧急指针</li><li>ACK：1 表示确认号有效，0 表示报文中不包含确认信息，忽略确认号字段</li><li>PSH：1 表示带有 PUSH 标志的数据，表示发送端缓存中已经没有待发送的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</li><li>RST：用于复位由于主机崩溃或其他原因出现的错误连接。还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定出现某些问题。</li><li>SYN：同步序号，1 表示连接请求；用于建立和使顺序号同步</li><li>FIN：用于释放连接，1 表示发送发应景没有数据发送了，即关闭本方数据流</li></ul></li><li>窗口大小：16 位，表示从确认号开始，本报文的源方可以接受的字节数，即源方接受窗口大小。窗口大小是 16bit 字段，因而窗口大小最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>2</mn><mn>16</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2_{16}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li><li>检验和：16 位，对整个 TCP 报文段（包括 TCP 头部和 TCP 数据以及伪报文头）进行校验和计算。这是一个强制性字段，要求由发送方计算和存储，并由接收端进行验证（接收端与发送端数值结果完全一样，才能证明数据是有效的）；</li><li>紧急指针：16 位，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式，只有当 URG 标志置 1 时紧急指针才有效；</li><li>选项：n*4 字节，常见的可选字段是最长报文大小 MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段 (为建立连接而设置 SYN 标志的那个段) 中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以需要添加填充位，使得报文长度为 32 位字的整数倍</li></ul><h2 id="usb"><a class="markdownIt-Anchor" href="#usb"></a> USB</h2><p><em>（有待补充…）</em></p><h2 id="mqtt"><a class="markdownIt-Anchor" href="#mqtt"></a> MQTT</h2><p><em>（有待补充…）</em></p><h2 id="wifi"><a class="markdownIt-Anchor" href="#wifi"></a> WIFI</h2><p><em>（有待补充…）</em></p><h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2><p><em>（有待补充…）</em></p><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><ul><li><a href="https://renesas-docs.100ask.net/zh/DShanMCU_RA6M5/object_oriented_module_programming_method_in_ARM_embedded_system/chapter6.html">百问网：串行通信接口</a></li><li><a href="https://blog.csdn.net/m0_38106923/article/details/126024970?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172152401816800222838066%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172152401816800222838066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126024970-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=UART&amp;spm=1018.2226.3001.4187">一文搞懂 UART 通信协议</a></li><li><a href="https://blog.csdn.net/MQ0522/article/details/128559845?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172153825116800172564359%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172153825116800172564359&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128559845-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=RS485&amp;spm=1018.2226.3001.4187">RS485 通信----基本原理+电路图</a></li><li><a href="https://blog.csdn.net/m0_38106923/article/details/123673285">一文搞懂 I2C 通信总线</a></li><li><a href="https://blog.csdn.net/lzxiaotu/article/details/119354515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172154100716800188578505%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172154100716800188578505&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-119354515-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=TTL&amp;spm=1018.2226.3001.4187">TTL、RS232、RS485</a></li><li><a href="https://blog.csdn.net/dpwkj/article/details/139060852?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-4-139060852-blog-119354515.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-4-139060852-blog-119354515.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=7">总结 UART、I2C、SPI、TTL、RS232、RS422、RS485、CAN、USB、SD 卡、1-WIRE、Ethernet</a></li><li><a href="https://blog.csdn.net/m0_38106923/article/details/124364676">一文搞懂 SPI 通信协议</a></li><li><a href="https://blog.csdn.net/m0_38106923/article/details/105285231">一文看懂 Modbus 协议</a></li><li><a href="https://blog.csdn.net/m0_38106923/article/details/108292454">一文搞懂 TCP 的三次握手和四次挥手</a></li><li><a href="https://mp.weixin.qq.com/s/_07AMQLo9gp7Ae0tP9LaoQ">一文搞懂 I2C 总线通信</a></li><li><a href="https://mp.weixin.qq.com/s/51sVyx8AcZOuCLVcWLz-6w">对不起！我还是坚持把 I2C 肝完了</a></li><li><a href="https://mp.weixin.qq.com/s/p4boYe7pua2vsWny4m1nmA">原来 SPI 并没有我想的那么简单</a></li><li><a href="https://blog.csdn.net/qq_35057766/article/details/135573375">CAN 总线通信详解 (超详细配 34 张高清图)</a></li><li><a href="https://blog.csdn.net/2401_86353562/article/details/140725426">网络原理：史上最全 tcp/ip 协议详解</a></li><li><a href="https://blog.csdn.net/gemengxia/article/details/115548105?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172343776616800185859635%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172343776616800185859635&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115548105-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%80%9A%E4%BF%A1&amp;spm=1018.2226.3001.4187">以太网通信及设计</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 串口协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式软考</title>
      <link href="/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E8%80%83/"/>
      <url>/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>嵌入式系统设计师考试大纲</p><link rel="stylesheet" type="text/css" href="auto-number-title.css" /><p><em>Notes</em>:<br />（I）、（II）和（III）表示掌握或熟悉的程度：</p><ul><li>（I）是指对所列知识要理解其内容及含义（理解）。</li><li>（II）指在有关问题中能直接使用（一般应用）。</li><li>（III）是指对所列知识要理解其确切含义及与其他知识的联系，能够进行叙述和解释，并能在实际问题的分析、综合、推理和判断等过程中运用（综合应用）。</li></ul><h1 id="考试科目-1嵌入式系统基础知识"><a class="markdownIt-Anchor" href="#考试科目-1嵌入式系统基础知识"></a> 考试科目 1：嵌入式系统基础知识</h1><h2 id="计算机系统的基础知识"><a class="markdownIt-Anchor" href="#计算机系统的基础知识"></a> 计算机系统的基础知识</h2><h3 id="数制及其转换"><a class="markdownIt-Anchor" href="#数制及其转换"></a> 数制及其转换</h3><h4 id="二进制-八进制-十进制和十六进制等常用数制及其相互转换ii"><a class="markdownIt-Anchor" href="#二进制-八进制-十进制和十六进制等常用数制及其相互转换ii"></a> 二进制、八进制、十进制和十六进制等常用数制及其相互转换（II）</h4><p>答：<br />2&lt;–&gt;8：3 位二进制对应 1 位八进制数，不足时补 0<br />2&lt;–&gt;16：4 位二进制对应 1 位十六进制数<br />2&lt;–&gt;10：n 位二进制数转十进制对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>累加，十进制转二进制使用短除法<br />8、16&lt;–&gt;10：先转二进制再转八、十六进制</p><h3 id="数据的表示"><a class="markdownIt-Anchor" href="#数据的表示"></a> 数据的表示</h3><h4 id="数值的原码-反码-补码-移码表示定点数和浮点数精度和溢出ii"><a class="markdownIt-Anchor" href="#数值的原码-反码-补码-移码表示定点数和浮点数精度和溢出ii"></a> 数值的原码、反码、补码、移码表示，定点数和浮点数，精度和溢出（II）</h4><p>答：<br />原码：第一位为符号位，8 位二进制取值范围为：[1111 1111, 0111 1111]。表示范围[-127, +127]<br />反码：正数的反码是其本身；负数的反码在源码的基础上，符号位不变，其余位取反。表示范围[-127, +127]<br />补码：正数的补码是其本身；负数的补码在反码的基础上+1。表示范围[-128， +127]<br />移码：将符号位取反的补码</p><p>浮点数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mi>R</mi><mi>e</mi></msup><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N = R^e*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>（M 为尾数，e 为指数/阶码，R 为基数）；阶码决定数值的范围，尾数决定数值的精度<br />定点数：固定小数点的位置（小数点越靠左，整个数值范围越小；小数点越靠右，数值精度越低）</p><h4 id="字符-汉字-声音-图像的编码方式i"><a class="markdownIt-Anchor" href="#字符-汉字-声音-图像的编码方式i"></a> 字符、汉字、声音、图像的编码方式（I）</h4><p>答：<br />字符编码方式：</p><ul><li>ASCII：使用 7 位二进制数表示 128 个字符（英文字母、数字和一些常见符号）</li><li>UTF-8：可变长度编码，几乎可以表示所有字符</li></ul><p>汉字编码方式：</p><ul><li>GB2312：中国国家标准，使用两个字节表示常用汉字字符</li><li>GBK 是 GB2312 的扩展编码，表示公衡多汉字</li><li>Unicode：国际常用汉字编码，使用两字节表示汉字</li></ul><p>声音编码方式：</p><ul><li>PCM：将模拟声音信号转换为数字信号的编码方式，常用于音乐和传输声音数据</li><li>MP3：是一种有压缩的音频编码方式，可以将声音压缩为较小的文件大小，常用于音乐和语音的存储和传输。</li></ul><p>图片编码方式：</p><ul><li>JPEG：是一种有损压缩的图像编码方式，常用于存储和传输照片和图像。</li><li>PNG：是一种无损压缩的图像编码方式，常用于存储和传输图标和界面元素。</li><li>GIF：是一种支持动画的图像编码方式，常用于表情包和简单动画的存储和传输。</li></ul><h4 id="校验方法和校验码奇偶校验码-海明校验码-循环冗余校验码ii"><a class="markdownIt-Anchor" href="#校验方法和校验码奇偶校验码-海明校验码-循环冗余校验码ii"></a> 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码）（II）</h4><p>答：</p><ul><li>奇/偶校验码：整个校验码（有效信息位+校验位）中 1 的个数为奇/偶数</li><li>海明检验码：k 位校验码，n 位信息码，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo lspace="0em" rspace="0em">≥</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k {\geq} n+k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord"><span class="mrel">≥</span></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；海明码规定，校验码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>要放在海明位号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>位置上；海明码具有 1 个比特位的纠错能力，和 2 个比特位的检错能力。</li><li>循环冗余校验码：收发双方约定好一个 生成多项式 G(x) ，发送方基于待发送的数据和生成多项式计算出 R 位校验码 ，将其添加到 K 位信息码 （待传输数据）的后面一起传输。对接收收到的信息与生成多项式系数所构成的比特串相除，看余数是否为 0<br /><img src="image-1.png" alt="alt text" /><br /><a href="https://blog.csdn.net/qq_46331050/article/details/122115456">参考文献</a></li></ul><h3 id="算术运算和逻辑运算"><a class="markdownIt-Anchor" href="#算术运算和逻辑运算"></a> 算术运算和逻辑运算</h3><h4 id="二进制数运算方法ii"><a class="markdownIt-Anchor" href="#二进制数运算方法ii"></a> 二进制数运算方法（II）</h4><p>答：<br />二进制数加法：逢二进一<br />二进制数减法：借一有二<br />二进制数乘/除法：按十进制来就行<br />逻辑“或”运算：有一出一<br />逻辑“与”运算：同一出一<br />逻辑“异或”运算：相同出 0，不同出 1</p><h4 id="逻辑代数的基本运算和逻辑表达式的化简i"><a class="markdownIt-Anchor" href="#逻辑代数的基本运算和逻辑表达式的化简i"></a> 逻辑代数的基本运算和逻辑表达式的化简（I）</h4><p>答：<img src="/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E8%80%83/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99.png" class="" title="逻辑代数的基本运算法则"></p><h3 id="计算机组成和主要部件的基本工作原理"><a class="markdownIt-Anchor" href="#计算机组成和主要部件的基本工作原理"></a> 计算机组成和主要部件的基本工作原理</h3><h4 id="cpu-和存储器的组成-基本工作原理"><a class="markdownIt-Anchor" href="#cpu-和存储器的组成-基本工作原理"></a> CPU 和存储器的组成、基本工作原理</h4><ul><li>CPU 的基本组成与工作原理（II）<br />答：</li><li>存储器的组成及特点（II）</li><li>信息存储的字节顺序（大端存储、小端存储）（II）</li></ul><h4 id="常用-io-设备-通信设备的性能以及基本工作原理i"><a class="markdownIt-Anchor" href="#常用-io-设备-通信设备的性能以及基本工作原理i"></a> 常用 I/O 设备、通信设备的性能以及基本工作原理（I）</h4><h4 id="io-接口的功能-类型和特点"><a class="markdownIt-Anchor" href="#io-接口的功能-类型和特点"></a> I/O 接口的功能、类型和特点</h4><ul><li>I/O 接口的基本组成与主要功能（II）</li><li>I/O 接口的分类（I）</li><li>I/O 接口的控制方式及特点：程序查询方式、中断处理方式、DMA（直接存储器存取）传送方式等（II）</li></ul><h3 id="计算机体系结构"><a class="markdownIt-Anchor" href="#计算机体系结构"></a> 计算机体系结构</h3><h4 id="cisc-risc-流水线技术-超标量等i"><a class="markdownIt-Anchor" href="#cisc-risc-流水线技术-超标量等i"></a> CISC、RISC、流水线技术、超标量等（I）</h4><h4 id="多处理机并行处理分布处理i"><a class="markdownIt-Anchor" href="#多处理机并行处理分布处理i"></a> 多处理机，并行处理，分布处理（I）</h4><h4 id="冯诺伊曼结构与哈佛结构i"><a class="markdownIt-Anchor" href="#冯诺伊曼结构与哈佛结构i"></a> 冯·诺伊曼结构与哈佛结构（I）</h4><h3 id="可靠性与系统性能评测基础知识"><a class="markdownIt-Anchor" href="#可靠性与系统性能评测基础知识"></a> 可靠性与系统性能评测基础知识</h3><h4 id="诊断与容错"><a class="markdownIt-Anchor" href="#诊断与容错"></a> 诊断与容错</h4><ul><li>故障诊断（I）</li><li>容错技术与容错控制（I）</li></ul><h4 id="系统可靠性分析评价"><a class="markdownIt-Anchor" href="#系统可靠性分析评价"></a> 系统可靠性分析评价</h4><ul><li>系统的可靠性定义（I）</li><li>串联系统特点及可靠性度量（I）</li><li>并联系统特点及可靠性度量（I）</li><li>N 模冗余系统等可靠性模型的特点（I）</li></ul><h4 id="计算机系统性能评测方法"><a class="markdownIt-Anchor" href="#计算机系统性能评测方法"></a> 计算机系统性能评测方法</h4><ul><li>平均无故障时间的定义及计算（I）</li><li>平均修复时间的定义及计算（I）</li><li>可用性的定义及计算（I）</li></ul><h2 id="嵌入式系统硬件基础知识"><a class="markdownIt-Anchor" href="#嵌入式系统硬件基础知识"></a> 嵌入式系统硬件基础知识</h2><h3 id="数字电路基础"><a class="markdownIt-Anchor" href="#数字电路基础"></a> 数字电路基础</h3><h4 id="信号特性与信号转换i"><a class="markdownIt-Anchor" href="#信号特性与信号转换i"></a> 信号特性与信号转换（I）</h4><h4 id="组合逻辑电路和时序逻辑电路i"><a class="markdownIt-Anchor" href="#组合逻辑电路和时序逻辑电路i"></a> 组合逻辑电路和时序逻辑电路（I）</h4><h4 id="可编程逻辑器件"><a class="markdownIt-Anchor" href="#可编程逻辑器件"></a> 可编程逻辑器件</h4><ul><li>CPLD 和 FPGA 的特点（I）</li><li>FPGA 的构成（I）</li></ul><h3 id="嵌入式微处理器基础"><a class="markdownIt-Anchor" href="#嵌入式微处理器基础"></a> 嵌入式微处理器基础</h3><h4 id="嵌入式微处理器的结构和类型"><a class="markdownIt-Anchor" href="#嵌入式微处理器的结构和类型"></a> 嵌入式微处理器的结构和类型</h4><ul><li>常用 8 位处理器的体系结构特点（II）</li><li>常用 16 位处理器的体系结构特点（II）</li><li>常用 32 位处理器的体系结构特点<ul><li>X86、ARM、PowerPC 系列（II）</li></ul></li><li>常用 DSP 处理器的体系结构特点<ul><li>典型的包括 TI 系列，ADI 系列，Freescale 系列（II）</li></ul></li><li>多核处理器的体系结构特点<ul><li>同构异构（II）</li><li>程序执行模型（II）</li><li>核间通信方法（II）</li></ul></li></ul><h4 id="嵌入式微处理器的异常与中断"><a class="markdownIt-Anchor" href="#嵌入式微处理器的异常与中断"></a> 嵌入式微处理器的异常与中断</h4><ul><li>异常<ul><li>陷阱（I）</li><li>故障（I）</li><li>终止（I）</li></ul></li><li>中断<ul><li>硬中断、软中断（II）</li><li>可屏蔽中断、不可屏蔽中断（II）</li><li>中断优先级（II）</li><li>中断嵌套（II）</li></ul></li></ul><h3 id="嵌入式系统的存储体系"><a class="markdownIt-Anchor" href="#嵌入式系统的存储体系"></a> 嵌入式系统的存储体系</h3><h4 id="存储系统的层次结构i"><a class="markdownIt-Anchor" href="#存储系统的层次结构i"></a> 存储系统的层次结构（I）</h4><h4 id="内存管理单元mmu"><a class="markdownIt-Anchor" href="#内存管理单元mmu"></a> 内存管理单元（MMU）</h4><ul><li>MMU 的功能和作用（I）</li></ul><h4 id="ram-和-rom-的种类与选型"><a class="markdownIt-Anchor" href="#ram-和-rom-的种类与选型"></a> RAM 和 ROM 的种类与选型</h4><ul><li>常见 RAM 类型<ul><li>SRAM、DRAM、DDRAM、NVRAM 各自的典型特性和不同点（I）</li></ul></li><li>常见 ROM 种类<ul><li>PROM、EPROM、EEPROM 和 ROM 各自的典型特征和不同点（I）</li></ul></li></ul><h4 id="高速缓存cache"><a class="markdownIt-Anchor" href="#高速缓存cache"></a> 高速缓存(Cache)</h4><ul><li>Cache 的分类（II）</li><li>Cache 的组成结构（II）</li><li>Cache 的工作原理（II）</li></ul><h4 id="其他存储设备"><a class="markdownIt-Anchor" href="#其他存储设备"></a> 其他存储设备</h4><ul><li>磁盘、光盘等存储介质（I）</li><li>闪存类存储介质（I）</li></ul><h3 id="嵌入式系统-io"><a class="markdownIt-Anchor" href="#嵌入式系统-io"></a> 嵌入式系统 I/O</h3><h4 id="gpio-pwm-接口基本原理和结构i"><a class="markdownIt-Anchor" href="#gpio-pwm-接口基本原理和结构i"></a> GPIO、PWM 接口基本原理和结构（I）</h4><h4 id="ad-da-接口基本原理与结构ii"><a class="markdownIt-Anchor" href="#ad-da-接口基本原理与结构ii"></a> A/D、D/A 接口基本原理与结构（II）</h4><h4 id="键盘-显示-触摸屏-声控屏等接口基本原理与结构ii"><a class="markdownIt-Anchor" href="#键盘-显示-触摸屏-声控屏等接口基本原理与结构ii"></a> 键盘、显示、触摸屏、声控屏等接口基本原理与结构（II）</h4><h4 id="嵌入式系统音频-视频接口i"><a class="markdownIt-Anchor" href="#嵌入式系统音频-视频接口i"></a> 嵌入式系统音频、视频接口（I）</h4><h4 id="输入输出控制ii"><a class="markdownIt-Anchor" href="#输入输出控制ii"></a> 输入输出控制（II）</h4><h3 id="定时器和计数器"><a class="markdownIt-Anchor" href="#定时器和计数器"></a> 定时器和计数器</h3><h4 id="定时器和计数器的工作原理i"><a class="markdownIt-Anchor" href="#定时器和计数器的工作原理i"></a> 定时器和计数器的工作原理（I）</h4><h4 id="定时器的设计ii"><a class="markdownIt-Anchor" href="#定时器的设计ii"></a> 定时器的设计（II）</h4><h4 id="计数器的设计ii"><a class="markdownIt-Anchor" href="#计数器的设计ii"></a> 计数器的设计（II）</h4><h3 id="嵌入式系统总线及通信接口"><a class="markdownIt-Anchor" href="#嵌入式系统总线及通信接口"></a> 嵌入式系统总线及通信接口</h3><ul><li>总线分类（II）</li><li>总线控制（II）</li><li>PCI、PCI-E、EISA、VME、CPCI、PCMCIA 等的基本原理和特点（II）</li><li>USB、串口、红外、并口、SPI、IIC、1394、CAN 等的基本原理和特点（II）</li><li>以太网、WLAN、蓝牙、Zigbee、WIFI、GPRS、3G、AFDX、FC 等基本原理和特点（II）</li><li>Select IO、Rapid IO 等告诉串行通信接口的基本原理和特点（II）</li></ul><h3 id="嵌入式系统电源分类及电源管理i"><a class="markdownIt-Anchor" href="#嵌入式系统电源分类及电源管理i"></a> 嵌入式系统电源分类及电源管理（I）</h3><h3 id="电子电路设计"><a class="markdownIt-Anchor" href="#电子电路设计"></a> 电子电路设计</h3><h4 id="电子电路设计基础知识"><a class="markdownIt-Anchor" href="#电子电路设计基础知识"></a> 电子电路设计基础知识</h4><ul><li>电子电路设计原理（I）</li><li>电子电路设计方法及步骤（I）</li><li>电子电路可靠性设计（I）</li></ul><h4 id="pcb-设计基础知识"><a class="markdownIt-Anchor" href="#pcb-设计基础知识"></a> PCB 设计基础知识</h4><ul><li>PCB 设计原理（I）</li><li>PCB 设计方法及步骤（I）</li><li>多层 PCB 设计的注意事项及布线原理（I）</li><li>PCB 的可靠性设计（电磁兼容）（I）</li></ul><h4 id="电子电路测试基础知识"><a class="markdownIt-Anchor" href="#电子电路测试基础知识"></a> 电子电路测试基础知识</h4><ul><li>电子电路测试方法（I）</li><li>硬件可靠性测试（I）</li></ul><h2 id="嵌入式系统软件基础知识"><a class="markdownIt-Anchor" href="#嵌入式系统软件基础知识"></a> 嵌入式系统软件基础知识</h2><h3 id="嵌入式软件基础知识"><a class="markdownIt-Anchor" href="#嵌入式软件基础知识"></a> 嵌入式软件基础知识</h3><h4 id="嵌入式软件分类"><a class="markdownIt-Anchor" href="#嵌入式软件分类"></a> 嵌入式软件分类</h4><ul><li>系统软件（I）</li><li>支撑软件<ul><li>中间件（I）</li><li>可配置组件（I）</li></ul></li><li>应用软件（I）</li></ul><h4 id="嵌入式系统初始化"><a class="markdownIt-Anchor" href="#嵌入式系统初始化"></a> 嵌入式系统初始化</h4><ul><li>系统引导（Bootloader）（II）</li><li>班级支持包（BSP）（II）</li></ul><h4 id="无操作系统支持的嵌入式软件体系结构i"><a class="markdownIt-Anchor" href="#无操作系统支持的嵌入式软件体系结构i"></a> 无操作系统支持的嵌入式软件体系结构（I）</h4><h4 id="有操作系统支持的嵌入式软件体系结构ii"><a class="markdownIt-Anchor" href="#有操作系统支持的嵌入式软件体系结构ii"></a> 有操作系统支持的嵌入式软件体系结构（II）</h4><h4 id="嵌入式支撑软件嵌入式文件系统-嵌入式数据库-分布式对象系统-gui-等ii"><a class="markdownIt-Anchor" href="#嵌入式支撑软件嵌入式文件系统-嵌入式数据库-分布式对象系统-gui-等ii"></a> 嵌入式支撑软件（嵌入式文件系统、嵌入式数据库、分布式对象系统、GUI 等）（II）</h4><h3 id="嵌入式系统基础知识"><a class="markdownIt-Anchor" href="#嵌入式系统基础知识"></a> 嵌入式系统基础知识</h3><h4 id="嵌入式操作系统基本概念"><a class="markdownIt-Anchor" href="#嵌入式操作系统基本概念"></a> 嵌入式操作系统基本概念</h4><ul><li>分类：模块化结构、分层结构、微内核结构、多重独立安全等级（MILS）结构等（II）</li><li>嵌入式实时操作系统特点：实时性、可移植性、可剪裁可配置性、可靠性、应用编程接口（API）等（I）</li><li>高可靠嵌入式实时操作系统：相关标准、分区概念、隔离保护、健康监控（I）</li></ul><h4 id="处理器管理"><a class="markdownIt-Anchor" href="#处理器管理"></a> 处理器管理</h4><ul><li>多道程序（I）</li><li>分区、进程、线程、任务的概念（II）</li><li>任务管理<ul><li>任务划分（II）</li><li>任务控制块（II）</li><li>任务的状态及状态转换（II）</li><li>任务队列（II）</li><li>任务管理机制（II）</li></ul></li><li>任务调度（调度算法的性能指标、可抢占调度、不可抢占调度、先来先服务算法、短作业优先算法、时间片轮转算法、优先级算法，使用率平衡算法、单调速率调度（RMS）算法、最早截止期限优先动态调度（EDF）算法，多处理器调度）（II）</li><li>优先级反转（优先级反转、优先级继承、优先级天花板等）（II）</li><li>任务间通信（共享内存、消息、邮箱、管道、信号等）（II）</li><li>同步与互斥（竞争条件、临界区、互斥、信号量、死锁等）（III）</li><li>高可靠性操作系统的分区调度、分区通信等（II）</li></ul><h4 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h4><ul><li>Flat 存储管理方式（I）</li><li>分区存储管理（固定分区、可变分区、内存保护等）（II）</li><li>地址重定位（逻辑地址、物理地址、地址映射等）（II）</li><li>页式存储管理（II）</li><li>虚拟存储技术（程序局部性原理、虚拟页式存储管理、页面置换算法等）（II）</li></ul><h4 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h4><ul><li>物理设备、逻辑设备、虚拟设备等（II）</li><li>设备分类（字符设备、块设备、网络设备）（II）</li><li>设备管理方式（设备文件、设备控制、设备无关性、中断处理、缓冲技术、假脱机技术等）（II）</li><li>设备驱动程序（II）</li></ul><h4 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h4><ul><li>文件和目录（II）</li><li>文件的结构和组织（II）</li><li>存取方法、存取控制（II）</li><li>常见嵌入式文件系统（FAT、JFFS、YAFFS 等）（I）</li><li>网络文件系统（I）</li></ul><h4 id="操作系统移植"><a class="markdownIt-Anchor" href="#操作系统移植"></a> 操作系统移植</h4><ul><li>硬件配置、板级支持包移植、驱动移植、系统配置、交叉编译、部署与测试等（I）</li></ul><h3 id="嵌入式系统程序设计"><a class="markdownIt-Anchor" href="#嵌入式系统程序设计"></a> 嵌入式系统程序设计</h3><h4 id="嵌入式软件开发基础知识"><a class="markdownIt-Anchor" href="#嵌入式软件开发基础知识"></a> 嵌入式软件开发基础知识</h4><ul><li>嵌入式软件开发模式，开发环境、开发工具等的选择（I）</li></ul><h4 id="嵌入式程序设计语言"><a class="markdownIt-Anchor" href="#嵌入式程序设计语言"></a> 嵌入式程序设计语言</h4><ul><li>编译器和解释器的基础知识（II）</li><li>汇编语言（指令系统、寻址方式、伪指令、宏指令等）（I）</li><li>混合编程（I）</li><li>过程式语言（过程/函数、参数传递、变量、递归、动态内存分配、数据类型等）（II）</li><li>面向对象语言（对象/类、数据抽象、继承、多态、重载等）（II）</li><li>嵌入式 C/C++程序设计要求（II）</li></ul><h4 id="嵌入式软件开发环境"><a class="markdownIt-Anchor" href="#嵌入式软件开发环境"></a> 嵌入式软件开发环境</h4><ul><li>宿主机、目标机（I）</li><li>编辑器、交叉工具链（编译器、链接器、调试器）、模拟器（II）</li><li>集成开发及仿真环境（II）</li><li>开发辅助工具（I）</li></ul><h4 id="嵌入式软件开发过程"><a class="markdownIt-Anchor" href="#嵌入式软件开发过程"></a> 嵌入式软件开发过程</h4><ul><li>嵌入式软件设计（II）</li><li>编码（编程规范、代码审查）（I）</li><li>软件集成（I）</li><li>测试（测试环境、测试用例、测试方法、测试工具）（II）</li><li>下载和运行（II）</li><li>第三方测试与验证（I）</li></ul><h4 id="嵌入式应用软件移植"><a class="markdownIt-Anchor" href="#嵌入式应用软件移植"></a> 嵌入式应用软件移植</h4><ul><li>无操作系统的软件移植（II）</li><li>有操作系统的软件移植（II）</li></ul><h2 id="嵌入式系统的项目开发与维护知识"><a class="markdownIt-Anchor" href="#嵌入式系统的项目开发与维护知识"></a> 嵌入式系统的项目开发与维护知识</h2><h3 id="系统开发过程及其项目管理"><a class="markdownIt-Anchor" href="#系统开发过程及其项目管理"></a> 系统开发过程及其项目管理</h3><h4 id="系统开发生命周期各阶段的目标和任务"><a class="markdownIt-Anchor" href="#系统开发生命周期各阶段的目标和任务"></a> 系统开发生命周期各阶段的目标和任务</h4><ul><li>项目描述、可行性分析、需求分析、总体设计、概要设计、详细设计、编码和单元测试、集成测试、运行维护（I）</li></ul><h4 id="系统开发项目管理基础知识及其常用管理工具"><a class="markdownIt-Anchor" href="#系统开发项目管理基础知识及其常用管理工具"></a> 系统开发项目管理基础知识及其常用管理工具</h4><ul><li>开发过程管理知识及工具（I）</li><li>成本管理知识及工具（I）</li><li>风险管理知识及工具（I）</li><li>质量管理知识及工具（I）</li></ul><h4 id="系统开发方法i"><a class="markdownIt-Anchor" href="#系统开发方法i"></a> 系统开发方法（I）</h4><h4 id="系统开发工具与环境i"><a class="markdownIt-Anchor" href="#系统开发工具与环境i"></a> 系统开发工具与环境（I）</h4><h3 id="系统分析知识"><a class="markdownIt-Anchor" href="#系统分析知识"></a> 系统分析知识</h3><h4 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h4><ul><li>功能性需求（I）</li><li>非功能性需求（I）</li></ul><h4 id="系统分析的目的和任务i"><a class="markdownIt-Anchor" href="#系统分析的目的和任务i"></a> 系统分析的目的和任务（I）</h4><h4 id="系统分析方法i"><a class="markdownIt-Anchor" href="#系统分析方法i"></a> 系统分析方法（I）</h4><h3 id="系统设计知识"><a class="markdownIt-Anchor" href="#系统设计知识"></a> 系统设计知识</h3><h4 id="系统设计方法i"><a class="markdownIt-Anchor" href="#系统设计方法i"></a> 系统设计方法（I）</h4><h4 id="系统架构及概要设计ii"><a class="markdownIt-Anchor" href="#系统架构及概要设计ii"></a> 系统架构及概要设计（II）</h4><h4 id="系统详细设计程序结构设计-模块接口设计-数据结构设计-用户界面设计等"><a class="markdownIt-Anchor" href="#系统详细设计程序结构设计-模块接口设计-数据结构设计-用户界面设计等"></a> 系统详细设计（程序结构设计、模块接口设计、数据结构设计、用户界面设计等）</h4><ul><li>程序结构设计（II）</li><li>模块接口设计（II）</li><li>数据结构设计（II）</li><li>处理过程设计（II）</li><li>用户界面设计（II）</li></ul><h4 id="软硬件协同设计方法"><a class="markdownIt-Anchor" href="#软硬件协同设计方法"></a> 软硬件协同设计方法</h4><ul><li>软硬件的功能划分（I）</li><li>单任务流图的软硬件协同设计方法（I）</li><li>多分支系统任务流图的软硬件协同设计方法（I）</li><li>并行系统任务流图的软硬件协同设计方法（I）</li></ul><h3 id="系统实施知识"><a class="markdownIt-Anchor" href="#系统实施知识"></a> 系统实施知识</h3><h4 id="软硬件平台搭建ii"><a class="markdownIt-Anchor" href="#软硬件平台搭建ii"></a> 软硬件平台搭建（II）</h4><h4 id="系统调试与测试ii"><a class="markdownIt-Anchor" href="#系统调试与测试ii"></a> 系统调试与测试（II）</h4><h3 id="系统运行和维护知识"><a class="markdownIt-Anchor" href="#系统运行和维护知识"></a> 系统运行和维护知识</h3><h4 id="系统运行管理i"><a class="markdownIt-Anchor" href="#系统运行管理i"></a> 系统运行管理（I）</h4><h4 id="系统维护"><a class="markdownIt-Anchor" href="#系统维护"></a> 系统维护</h4><ul><li>系统维护的目的与任务（I）</li><li>系统维护的内容：硬件设备维护、程序维护、数据维护等（I）</li><li>系统维护的类型：完善性维护、适应性维护、改正性维护、预防性维护等（II）</li></ul><h4 id="系统评价i"><a class="markdownIt-Anchor" href="#系统评价i"></a> 系统评价（I）</h4><h2 id="嵌入式系统的安全性知识"><a class="markdownIt-Anchor" href="#嵌入式系统的安全性知识"></a> 嵌入式系统的安全性知识</h2><h3 id="安全性基本概念"><a class="markdownIt-Anchor" href="#安全性基本概念"></a> 安全性基本概念</h3><ul><li>网络安全、信息安全等基础知识（I）</li><li>防治计算机病毒、防范计算机犯罪、防闯入、防灾等（I）</li><li>保障完整性与可用性的措施（I）</li><li>风险管理与控制（风险分析、风险类型、风险控制手段）（I）</li></ul><h3 id="嵌入式系统的安全性设计"><a class="markdownIt-Anchor" href="#嵌入式系统的安全性设计"></a> 嵌入式系统的安全性设计</h3><ul><li>硬件安全性设计（I）</li><li>软件安全性设计（I）</li></ul><h3 id="嵌入式系统的信息安全加密与解密-访问控制等"><a class="markdownIt-Anchor" href="#嵌入式系统的信息安全加密与解密-访问控制等"></a> 嵌入式系统的信息安全（加密与解密、访问控制等）</h3><ul><li>加密与解密机制基础知识（II）</li><li>访问控制（I）</li></ul><h2 id="标准化知识"><a class="markdownIt-Anchor" href="#标准化知识"></a> 标准化知识</h2><h3 id="标准化的概念和标准化机构i"><a class="markdownIt-Anchor" href="#标准化的概念和标准化机构i"></a> 标准化的概念和标准化机构（I）</h3><h3 id="国际标准-国家标准-行业标准-企业标准基本知识i"><a class="markdownIt-Anchor" href="#国际标准-国家标准-行业标准-企业标准基本知识i"></a> 国际标准、国家标准、行业标准、企业标准基本知识（I）</h3><h3 id="代码标准-文件格式标准-安全标准-软件开发规范和文档标准知识i"><a class="markdownIt-Anchor" href="#代码标准-文件格式标准-安全标准-软件开发规范和文档标准知识i"></a> 代码标准、文件格式标准、安全标准、软件开发规范和文档标准知识（I）</h3><h3 id="嵌入式系统相关标准i"><a class="markdownIt-Anchor" href="#嵌入式系统相关标准i"></a> 嵌入式系统相关标准（I）</h3><h2 id="信息化和知识产权基础知识"><a class="markdownIt-Anchor" href="#信息化和知识产权基础知识"></a> 信息化和知识产权基础知识</h2><h3 id="信息化基础知识"><a class="markdownIt-Anchor" href="#信息化基础知识"></a> 信息化基础知识</h3><ul><li>全球信息化趋势、国家信息化战略、企业信息化战略和策略（I）</li><li>信息化意识，有关的法律、法规（I）</li><li>远程教育、电子商务、电子政务等基础知识（I）</li><li>企业信息资源管理基础知识（I）</li></ul><h3 id="知识产权基础知识"><a class="markdownIt-Anchor" href="#知识产权基础知识"></a> 知识产权基础知识</h3><ul><li>专利法、商标法、商业秘密权对软件的保护（I）</li><li>软件有关的法律、法规方面的基础知识（I）</li><li>著作权法、软件保护条例及软件著作登记的基础知识（I）</li><li>软件著作权主体与客体、权利内容、权利归属、侵权责任，分析侵权行为（II）</li></ul><h2 id="嵌入式技术发展趋势"><a class="markdownIt-Anchor" href="#嵌入式技术发展趋势"></a> 嵌入式技术发展趋势</h2><h3 id="嵌入式系统硬件发展趋势i"><a class="markdownIt-Anchor" href="#嵌入式系统硬件发展趋势i"></a> 嵌入式系统硬件发展趋势（I）</h3><h3 id="嵌入式系统软件发展趋势i"><a class="markdownIt-Anchor" href="#嵌入式系统软件发展趋势i"></a> 嵌入式系统软件发展趋势（I）</h3><h2 id="计算机专业英语"><a class="markdownIt-Anchor" href="#计算机专业英语"></a> 计算机专业英语</h2><ul><li>正确阅读理解嵌入式系统相关领域的英文资料（I）</li></ul><h1 id="考试科目-2嵌入式系统设计"><a class="markdownIt-Anchor" href="#考试科目-2嵌入式系统设计"></a> 考试科目 2：嵌入式系统设计</h1><h2 id="嵌入式系统开发过程"><a class="markdownIt-Anchor" href="#嵌入式系统开发过程"></a> 嵌入式系统开发过程</h2><h3 id="系统开发过程管理"><a class="markdownIt-Anchor" href="#系统开发过程管理"></a> 系统开发过程管理</h3><h4 id="生命周期-成本及工作量估计iii"><a class="markdownIt-Anchor" href="#生命周期-成本及工作量估计iii"></a> 生命周期、成本及工作量估计（III）</h4><h4 id="风险管理ii"><a class="markdownIt-Anchor" href="#风险管理ii"></a> 风险管理（II）</h4><h4 id="开发模型"><a class="markdownIt-Anchor" href="#开发模型"></a> 开发模型</h4><ul><li>瀑布模型、快速原型、增量模型、螺旋模型等（II）</li></ul><h4 id="质量管理ii"><a class="markdownIt-Anchor" href="#质量管理ii"></a> 质量管理（II）</h4><h4 id="配置管理ii"><a class="markdownIt-Anchor" href="#配置管理ii"></a> 配置管理（II）</h4><h4 id="软件成熟度模型ii"><a class="markdownIt-Anchor" href="#软件成熟度模型ii"></a> 软件成熟度模型（II）</h4><h3 id="需求分析-2"><a class="markdownIt-Anchor" href="#需求分析-2"></a> 需求分析</h3><h4 id="用户需求ii"><a class="markdownIt-Anchor" href="#用户需求ii"></a> 用户需求（II）</h4><h4 id="系统定义ii"><a class="markdownIt-Anchor" href="#系统定义ii"></a> 系统定义（II）</h4><h4 id="需求规格说明书ii"><a class="markdownIt-Anchor" href="#需求规格说明书ii"></a> 需求规格说明书（II）</h4><h4 id="需求评审ii"><a class="markdownIt-Anchor" href="#需求评审ii"></a> 需求评审（II）</h4><h3 id="系统设计"><a class="markdownIt-Anchor" href="#系统设计"></a> 系统设计</h3><h4 id="系统方案设计iii"><a class="markdownIt-Anchor" href="#系统方案设计iii"></a> 系统方案设计（III）</h4><h4 id="系统功能划分iii"><a class="markdownIt-Anchor" href="#系统功能划分iii"></a> 系统功能划分（III）</h4><h4 id="软硬件协同设计iii"><a class="markdownIt-Anchor" href="#软硬件协同设计iii"></a> 软硬件协同设计（III）</h4><h4 id="硬件设计"><a class="markdownIt-Anchor" href="#硬件设计"></a> 硬件设计</h4><ul><li>原理图设计（II）</li><li>原理图分析与评审（II）</li><li>PCB 设计与评审（I）</li></ul><h4 id="软件设计"><a class="markdownIt-Anchor" href="#软件设计"></a> 软件设计</h4><ul><li>概要设计（III）</li><li>详细设计（III）</li><li>设计评审（II）</li></ul><h3 id="系统开发环境"><a class="markdownIt-Anchor" href="#系统开发环境"></a> 系统开发环境</h3><h4 id="开发平台"><a class="markdownIt-Anchor" href="#开发平台"></a> 开发平台</h4><ul><li>操作系统（I）</li><li>VxWorks、Windows CE、嵌入式 Linux、μCOSⅡ、……</li><li>分布式开发环境（I）</li></ul><h4 id="开发工具"><a class="markdownIt-Anchor" href="#开发工具"></a> 开发工具</h4><ul><li>文本编辑器（II）</li><li>集成开发环境（II）</li><li>配置管理工具（II）</li><li>逆向工程工具（I）</li></ul><h3 id="系统测试"><a class="markdownIt-Anchor" href="#系统测试"></a> 系统测试</h3><h4 id="测试环境ii"><a class="markdownIt-Anchor" href="#测试环境ii"></a> 测试环境（II）</h4><h4 id="测试计划内容-方法-标准-过程-检验iii"><a class="markdownIt-Anchor" href="#测试计划内容-方法-标准-过程-检验iii"></a> 测试计划（内容、方法、标准、过程、检验）（III）</h4><h4 id="硬件测试ii"><a class="markdownIt-Anchor" href="#硬件测试ii"></a> 硬件测试（II）</h4><h4 id="软件测试单元测试-集成测试-系统测试等iii"><a class="markdownIt-Anchor" href="#软件测试单元测试-集成测试-系统测试等iii"></a> 软件测试（单元测试、集成测试、系统测试等）（III）</h4><h4 id="软硬件联合测试ii"><a class="markdownIt-Anchor" href="#软硬件联合测试ii"></a> 软硬件联合测试（II）</h4><h3 id="系统评价i-2"><a class="markdownIt-Anchor" href="#系统评价i-2"></a> 系统评价（I）</h3><h3 id="系统维护-2"><a class="markdownIt-Anchor" href="#系统维护-2"></a> 系统维护</h3><h4 id="系统可维护性概念i"><a class="markdownIt-Anchor" href="#系统可维护性概念i"></a> 系统可维护性概念（I）</h4><h4 id="系统维护的内容及类型i"><a class="markdownIt-Anchor" href="#系统维护的内容及类型i"></a> 系统维护的内容及类型（I）</h4><h4 id="系统维护管理i"><a class="markdownIt-Anchor" href="#系统维护管理i"></a> 系统维护管理（I）</h4><h3 id="开发文档i"><a class="markdownIt-Anchor" href="#开发文档i"></a> 开发文档（I）</h3><h2 id="嵌入式系统硬件设计"><a class="markdownIt-Anchor" href="#嵌入式系统硬件设计"></a> 嵌入式系统硬件设计</h2><h3 id="嵌入式系统硬件基本结构"><a class="markdownIt-Anchor" href="#嵌入式系统硬件基本结构"></a> 嵌入式系统硬件基本结构</h3><h4 id="嵌入式微处理器结构iii"><a class="markdownIt-Anchor" href="#嵌入式微处理器结构iii"></a> 嵌入式微处理器结构（III）</h4><h4 id="数字信号处理器dsp结构iii"><a class="markdownIt-Anchor" href="#数字信号处理器dsp结构iii"></a> 数字信号处理器(DSP)结构（III）</h4><h4 id="异常及中断处理iii"><a class="markdownIt-Anchor" href="#异常及中断处理iii"></a> 异常及中断处理（III）</h4><h4 id="dma-技术ii"><a class="markdownIt-Anchor" href="#dma-技术ii"></a> DMA 技术（II）</h4><h4 id="多处理器系统"><a class="markdownIt-Anchor" href="#多处理器系统"></a> 多处理器系统</h4><ul><li>多处理器系统特点（I）</li><li>多处理器系统构建技术（多处理器、单处理器多核）（II）</li></ul><h4 id="总线i"><a class="markdownIt-Anchor" href="#总线i"></a> 总线（I）</h4><h4 id="数字电路"><a class="markdownIt-Anchor" href="#数字电路"></a> 数字电路</h4><ul><li>组合逻辑电路与时序逻辑电路设计（I）</li><li>可编程逻辑器件（FPGA/CPLD）的系统设计（III）</li></ul><h3 id="硬件描述语言vhdlverilog-hdl-等ii"><a class="markdownIt-Anchor" href="#硬件描述语言vhdlverilog-hdl-等ii"></a> 硬件描述语言（VHDL，Verilog HDL 等）（II）</h3><h3 id="大规模集成电路系统设计"><a class="markdownIt-Anchor" href="#大规模集成电路系统设计"></a> 大规模集成电路系统设计</h3><ul><li>ASIC 设计（I）</li><li>FPGA 设计（I）</li><li>SOC 设计（I）</li></ul><h3 id="输入输出接口"><a class="markdownIt-Anchor" href="#输入输出接口"></a> 输入/输出接口</h3><h4 id="接口的特性机械-电气-功能-规程i"><a class="markdownIt-Anchor" href="#接口的特性机械-电气-功能-规程i"></a> 接口的特性（机械、电气、功能、规程）（I）</h4><h4 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h4><ul><li>接口信号电平转换（I）</li><li>接口驱动电路设计（I）</li></ul><h4 id="接口应用"><a class="markdownIt-Anchor" href="#接口应用"></a> 接口应用</h4><ul><li>GPIO 接口（I）</li><li>USB 接口（I）</li><li>串行接口（I）</li><li>并行接口（II）</li><li>A/D、D/A 转换接口（III）</li><li>高速串行接口（Rapid IO，Select IO）（III）</li><li>音视频接口（II）</li><li>显示接口（III）</li><li>射频接口（II）</li><li>通信标准和协议（II）</li></ul><h3 id="电源设计i"><a class="markdownIt-Anchor" href="#电源设计i"></a> 电源设计（I）</h3><h3 id="低功耗设计i"><a class="markdownIt-Anchor" href="#低功耗设计i"></a> 低功耗设计（I）</h3><h3 id="可靠性与安全性设计"><a class="markdownIt-Anchor" href="#可靠性与安全性设计"></a> 可靠性与安全性设计</h3><h4 id="冗余设计ii"><a class="markdownIt-Anchor" href="#冗余设计ii"></a> 冗余设计（II）</h4><h4 id="可维护性设计i"><a class="markdownIt-Anchor" href="#可维护性设计i"></a> 可维护性设计（I）</h4><h4 id="系统容错与恢复设计ii"><a class="markdownIt-Anchor" href="#系统容错与恢复设计ii"></a> 系统容错与恢复设计（II）</h4><h3 id="系统仿真"><a class="markdownIt-Anchor" href="#系统仿真"></a> 系统仿真</h3><ul><li>仿真方法（I）</li><li>仿真工具（I）</li></ul><h2 id="嵌入式系统软件设计"><a class="markdownIt-Anchor" href="#嵌入式系统软件设计"></a> 嵌入式系统软件设计</h2><h3 id="嵌入式程序设计"><a class="markdownIt-Anchor" href="#嵌入式程序设计"></a> 嵌入式程序设计</h3><h4 id="汇编语言程序设计ii"><a class="markdownIt-Anchor" href="#汇编语言程序设计ii"></a> 汇编语言程序设计（II）</h4><h4 id="嵌入式-c-语言程序设计"><a class="markdownIt-Anchor" href="#嵌入式-c-语言程序设计"></a> 嵌入式 C 语言程序设计</h4><ul><li>数据结构设计（III）</li><li>运算符、表达式、语句、函数定义与函数调用、预处理指令等 （III）</li><li>C 程序设计及优化（III）</li></ul><h4 id="面向对象程序设计"><a class="markdownIt-Anchor" href="#面向对象程序设计"></a> 面向对象程序设计</h4><ul><li>使用 C++、C#或 Java 语言进行嵌入式程序设计（III）</li></ul><h3 id="系统软件设计"><a class="markdownIt-Anchor" href="#系统软件设计"></a> 系统软件设计</h3><h4 id="系统初始化设计i"><a class="markdownIt-Anchor" href="#系统初始化设计i"></a> 系统初始化设计（I）</h4><h4 id="硬件抽象层hal-板级支持包bsp设计iii"><a class="markdownIt-Anchor" href="#硬件抽象层hal-板级支持包bsp设计iii"></a> 硬件抽象层（HAL）、板级支持包（BSP）设计（III）</h4><h4 id="设备驱动程序设计iii"><a class="markdownIt-Anchor" href="#设备驱动程序设计iii"></a> 设备驱动程序设计（III）</h4><h4 id="嵌入式系统软件的移植i"><a class="markdownIt-Anchor" href="#嵌入式系统软件的移植i"></a> 嵌入式系统软件的移植（I）</h4><h4 id="嵌入式系统软件的移植"><a class="markdownIt-Anchor" href="#嵌入式系统软件的移植"></a> 嵌入式系统软件的移植</h4><h3 id="嵌入式操作系统"><a class="markdownIt-Anchor" href="#嵌入式操作系统"></a> 嵌入式操作系统</h3><h4 id="处理器管理-2"><a class="markdownIt-Anchor" href="#处理器管理-2"></a> 处理器管理</h4><ul><li>任务（进程、线程等）定义与调度（III）</li><li>任务的同步与通信（III）</li></ul><h4 id="存储管理-2"><a class="markdownIt-Anchor" href="#存储管理-2"></a> 存储管理</h4><ul><li>内存管理单元 MMU（II）</li><li>高速缓存（II）</li></ul><h4 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h4><ul><li>异常处理方法（II）</li><li>中断优先级处理方法（III）</li><li>系统调用（II）</li></ul><h4 id="常见嵌入式操作系统"><a class="markdownIt-Anchor" href="#常见嵌入式操作系统"></a> 常见嵌入式操作系统</h4><ul><li>Linux、WinCE、VxWorks、Android、uCOSⅡ 等（I）</li></ul><h3 id="嵌入式支撑系统"><a class="markdownIt-Anchor" href="#嵌入式支撑系统"></a> 嵌入式支撑系统</h3><h4 id="嵌入式系统中间件ii"><a class="markdownIt-Anchor" href="#嵌入式系统中间件ii"></a> 嵌入式系统中间件（II）</h4><h4 id="嵌入式文件系统"><a class="markdownIt-Anchor" href="#嵌入式文件系统"></a> 嵌入式文件系统</h4><ul><li>Ext2，Ext3 文件系统 （II）</li><li>Yaffs，jffs，Jffs2 文件系统（II）</li><li>Romfs，ramfs，cramfs 文件系统（II）</li></ul><h4 id="嵌入式系统数据库sqlite-数据库等ii"><a class="markdownIt-Anchor" href="#嵌入式系统数据库sqlite-数据库等ii"></a> 嵌入式系统数据库（SQLite 数据库等）（II）</h4><h4 id="嵌入式系统图形用户接口guiii"><a class="markdownIt-Anchor" href="#嵌入式系统图形用户接口guiii"></a> 嵌入式系统图形用户接口（GUI）（II）</h4><h4 id="嵌入式网络程序设计"><a class="markdownIt-Anchor" href="#嵌入式网络程序设计"></a> 嵌入式网络程序设计</h4><ul><li>Socket 程序设计（II）</li><li>WEB 程序设计（II）</li></ul><h2 id="嵌入式实时系统与分布式系统设计"><a class="markdownIt-Anchor" href="#嵌入式实时系统与分布式系统设计"></a> 嵌入式实时系统与分布式系统设计</h2><h3 id="实时系统的分析与设计i"><a class="markdownIt-Anchor" href="#实时系统的分析与设计i"></a> 实时系统的分析与设计（I）</h3><h3 id="分布式系统设计"><a class="markdownIt-Anchor" href="#分布式系统设计"></a> 分布式系统设计</h3><h4 id="分布式系统设计原理i"><a class="markdownIt-Anchor" href="#分布式系统设计原理i"></a> 分布式系统设计原理（I）</h4><h4 id="分布式系统设计方法i"><a class="markdownIt-Anchor" href="#分布式系统设计方法i"></a> 分布式系统设计方法（I）</h4><h4 id="分布式系统的通信技术i"><a class="markdownIt-Anchor" href="#分布式系统的通信技术i"></a> 分布式系统的通信技术（I）</h4><h4 id="分布式系统应用ii"><a class="markdownIt-Anchor" href="#分布式系统应用ii"></a> 分布式系统应用（II）</h4><h2 id="嵌入式系统应用"><a class="markdownIt-Anchor" href="#嵌入式系统应用"></a> 嵌入式系统应用</h2><ul><li>嵌入式系统在通信、交通、工业控制、航空航天等领域的应用（III）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路基础与设计</title>
      <link href="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="电路元件"><a class="markdownIt-Anchor" href="#电路元件"></a> 电路元件</h2><ul><li>电阻元件：<ul><li>欧姆定律适用于线性电阻</li><li>电阻的倒数称为电导</li></ul></li><li>独立源：<ul><li>独立电压源：不管外部电路如何，其两端电压总能保持定值（直流源）或给定的时间函数（交流源）的电源被称为独立电压源，不随电流变化。</li><li>独立电流源：不管外部电路如何，其两端电流总能保持定值（直流源）或给定的时间函数（交流源）的电源被称为独立电流源，不随电压变化。</li></ul></li><li>受控源：<ul><li>受控电压源<ul><li>电压控制电压源（VCVS）</li><li>电流控制电压源（CCVS）</li></ul></li><li>受控电流源<ul><li>电压控制电流源（VCCS）</li><li>电流控制电流源（CCCS）</li></ul></li></ul></li></ul><h2 id="电路基本定律"><a class="markdownIt-Anchor" href="#电路基本定律"></a> 电路基本定律</h2><ul><li><p>KCL：任意节点电流和为 0</p><ul><li>本质上是电荷守恒原理，即到达任何节点的电荷不可能增生，也不可能小时，电流必须连续流动</li><li>KCL 只与电路的结构相关，与构成电路的元件无关</li><li>适用于节点，也适用于任何一个封闭曲面</li><li>列写方程时：设出每一支路电流参考方向，流出和=流入和</li><li>注意 KCL 方程中的正负号与电流本身的正负号的区别</li></ul></li><li><p>KVL：对于参数电路，在任何一时刻，沿任一回路巡行一周，各支路(元件)电压降的代数和为 0。</p></li></ul><h2 id="电路分析方法"><a class="markdownIt-Anchor" href="#电路分析方法"></a> 电路分析方法</h2><ul><li>电路的数值极性表示法<ul><li>参考点：0 电位</li></ul></li><li>电路等效：对任何电路 A，如果用 C 代替 B 后，能做到 A 中的电流、电压、功率不变，则说 C 与 B 等效<ul><li>△ 形与 Y 形电路等效：列 KCL 和 KVL 进行等效替换</li><li>电压串联等效，电流源并联等效</li><li>平衡电桥：等电位间连接任意阻值电阻，不影响外电路的支路量–&gt;电桥平衡的条件为相对臂上的电阻乘积相等</li></ul></li><li>KCL 独立方程/KVL 独立方程：对于 n 个节点、b 条支路有且仅有(b-n+1)个独立的 KVL 方程<ul><li>(b-n+1)个基本回路</li><li>平面电路的(b-n+1)个网孔</li></ul></li><li>2b 法和支路法<ul><li>2b 法：以 b 个支路电压和 b 个支路为未知量列写并求解方程的方法称为 2b 法</li><li>支路法：以支路电流或电压为未知量列出方程，求解支路电流(或电压)，称为支路电流(或电压法)，简称支路法</li></ul></li><li>回路法：假设每个回路是独立的且完备的，用该回路上的电流来表示电路中待求解的未知变量，再通过 KCL 或 KVL 求解</li><li>节点法：在电路中任意选择一个节点为参考节点，其余节点与参考节点之间的电压，称为节点电压，其余同上</li></ul><h2 id="电容的特性"><a class="markdownIt-Anchor" href="#电容的特性"></a> 电容的特性</h2><ul><li>微观原理：电路中电子流向与电流方向相反，当电路接通时，电池负极连接的电容接受电子，电子逐渐增多；电池正极处失去电子，正电荷增多；当电路处于一种“平衡”–电子不再移动，则电容起到分压作用。同时，当一段稳定的电容电路移除电容，原本聚集在电容板上的电子相反的方向移动，充当了“电池”的角色。</li></ul><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><ul><li>降压：电容带有容抗且不做功，电容容抗通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>c</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>∗</mo><mi>π</mi><mo>∗</mo><mi>f</mi><mi>c</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">X_c= \frac{1}{2*π*fc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">c</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> f 是频率，c 是电容容量<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E9%99%8D%E5%8E%8B%E7%94%B5%E8%B7%AF.png" class="" title="降压电路"></li><li>滤波：利用电容滤波 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>c</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>∗</mo><mi>π</mi><mo>∗</mo><mi>f</mi><mi>c</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">X_c= \frac{1}{2*π*fc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">c</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，当 f 很高（对应高频率），输出容抗为 0，高频能通过，低频不能通过，因此高通滤波器<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF.png" class="" title="高通滤波电路"></li><li>延时：电容充电从 10%到 90%需要的时间是 2.2RC，选取合适的 RC 值实现延时<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E5%BB%B6%E6%97%B6%E7%94%B5%E8%B7%AF.png" class="" title="延时电路"></li><li>耦合：电容可以滤除直流成分，只通过交流<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%80%A6%E5%90%88%E7%94%B5%E8%B7%AF.png" class="" title="耦合电路"></li><li>旁路：滤除高频信号<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E6%97%81%E8%B7%AF%E7%94%B5%E8%B7%AF.png" class="" title="旁路电路"><a href="https://www.bilibili.com/video/BV1UU4y1r72W/?spm_id_from=333.337.search-card.all.click">参考视频</a></li></ul><h2 id="电感的特性"><a class="markdownIt-Anchor" href="#电感的特性"></a> 电感的特性</h2><ul><li>用于交流电场合</li><li>电感上会发生电磁感应</li><li>作用<ul><li>储存能量：手机充电器<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%94%B5%E6%84%9F%E5%82%A8%E5%AD%98%E8%83%BD%E9%87%8F%E7%94%B5%E8%B7%AF.png" class="" title="电感储存能量电路电路"></li><li>选择信号<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%94%B5%E6%84%9F%E9%80%89%E6%8B%A9%E4%BF%A1%E5%8F%B7%E7%94%B5%E8%B7%AF.png" class="" title="电感选择信号电路"></li></ul></li></ul><h2 id="三极管的特性"><a class="markdownIt-Anchor" href="#三极管的特性"></a> 三极管的特性</h2><ul><li>N 型掺杂(N)：添加 5 价磷（多余电子）；P 型掺杂：添加 3 价硼（多余正电荷）<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/PN%E7%BB%93%E5%8E%9F%E7%90%86.png" class="" title="PN结原理"></li><li>三极管微观原理：高浓度 N 型掺杂+P 型掺杂+N 型掺杂<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%89%E6%9E%81%E7%AE%A1%E5%BE%AE%E8%A7%82%E5%8E%9F%E7%90%86.png" class="" title="三极管微观原理图"><a href="https://www.bilibili.com/video/BV1fB4y147Gn/?spm_id_from=333.788&amp;vd_source=3a9f66a8e4f96fbd39b999e86b2e0cf4">参考视频</a></li><li>三极管三大放大电路:<img src="/2023/08/09/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" class="" title="三大放大电路"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>B</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{BE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0.7V --&gt; 三极管导通；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>C</mi></msub><mo>=</mo><mi>β</mi><msub><mi>I</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">I_C = \beta I_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>C</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>β</mi><msub><mi>I</mi><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I_C = (1+\beta I_C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>l</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>τ</mi><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>N</mi></mrow></munderover><msub><mi mathvariant="double-struck">L</mi><mrow><mo stretchy="false">[</mo><mi>k</mi><mo mathvariant="normal">≠</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></msub><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>τ</mi><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">l_{i,j}=-log\frac{\exp(sim(z_i,z_j)/\tau)}{\sum_{k=1}^{2N} \mathbb{L}_{[k\ne i]}{\exp(sim(z_i,z_k)/\tau)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.653431em;vertical-align:-1.2264309999999998em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">L</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2264309999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>τ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exp(sim(z_i,z_j)/\tau)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span></span></p><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><ul><li><a href="https://www.bilibili.com/video/BV15s411P7qz/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3a9f66a8e4f96fbd39b999e86b2e0cf4">https://www.bilibili.com/video/BV15s411P7qz/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3a9f66a8e4f96fbd39b999e86b2e0cf4</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 电路分析基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的一些常用命令~</title>
      <link href="/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="什么是-git"><a class="markdownIt-Anchor" href="#什么是-git"></a> 什么是 Git ？</h2><p>Git 是一个分布式版本控制系统，用于跟踪文件的变化并协调多人之间的文件更改。它允许多个用户在不同的分支上独立工作，并能够合并不同分支上的更改。Git 可以存储文件的完整历史记录，方便回溯和恢复文件的不同版本。它广泛用于软件开发中，特别是用于团队合作开发和开源项目。通过使用 Git，开发人员可以更好地管理和追踪代码的变化，确保团队成员之间的协作无缝进行。(来自 ChatGPT)</p><h2 id="git-的安装"><a class="markdownIt-Anchor" href="#git-的安装"></a> Git 的安装</h2><ul><li>Git 支持 Linux/Unix、macOS、Windows 平台使用，安装包地址：<a href="http://git-scm.com/downloads">git 下载与安装</a></li><li>Git 安装之后，在终端输入 git version 或 git --version 查看版本信息（顺便确保安装成功）。</li></ul><h2 id="git-的配置"><a class="markdownIt-Anchor" href="#git-的配置"></a> Git 的配置</h2><ul><li>设置个人用户名和电子邮件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;miaomiaomiao&quot;</span>  <span class="comment"># 设置个人用户名</span></span><br><span class="line">$ git config --global user.email miaomiao@163.com  <span class="comment"># 设置电子邮件</span></span><br></pre></td></tr></table></figure><ul><li>设置提交文件大小的上限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure><ul><li>Git 查看已有配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line"><span class="comment"># http.postbuffer=2M   // 这个什么</span></span><br><span class="line"><span class="comment"># user.name=miaomiaomiao</span></span><br><span class="line"><span class="comment"># user.email=miaomiaomiao@163.com</span></span><br></pre></td></tr></table></figure><h2 id="git-的工作流程和原理"><a class="markdownIt-Anchor" href="#git-的工作流程和原理"></a> Git 的工作流程和原理</h2><p>（待补充~）</p><h2 id="git-创建和克隆仓库"><a class="markdownIt-Anchor" href="#git-创建和克隆仓库"></a> Git 创建和克隆仓库</h2><ul><li>git init</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="comment"># 初始化空的 Git 存储库</span></span><br><span class="line">git init miaomiao <span class="comment"># 指目录作为 git repo</span></span><br></pre></td></tr></table></figure><ul><li>git clone xxxx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yutto-dev/yutto.git  <span class="comment"># 想 clone 到本地的 repo，以一个B站下载器为例</span></span><br></pre></td></tr></table></figure><h2 id="git-基本操作"><a class="markdownIt-Anchor" href="#git-基本操作"></a> Git 基本操作</h2><ul><li>git init 初始化仓库</li><li>git add . 添加所有文件到暂存区</li><li>git commit -m “xxxx” 添加 message 将暂存区提交到本地仓库，形成一个新的版本，生成一个指定 commit ID 标识号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a <span class="comment"># 不需要 git add 直接提交</span></span><br></pre></td></tr></table></figure><ul><li>git status 查看仓库当前状态，显示有变更的文件</li><li>git diff 比较文件的不同，即暂存区和工作区的差异</li><li>git reset 回退版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^ <span class="comment"># 回退到上一个版本</span></span><br><span class="line">git reset HEAD^2 <span class="comment"># 回退到上上一个版本</span></span><br><span class="line">git reset --hard HEAD^ <span class="comment">#（强）回退到上一个版本，会删除之前所有的提交信息</span></span><br><span class="line"></span><br><span class="line">git reset  d4d0b27adcc07b4c1af2aa945157b196b98c8feb <span class="comment"># 回退到指定版本号</span></span><br></pre></td></tr></table></figure><img src="/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.png" class="" title="commit记录"><ul><li>git rm 将文件从暂存区和工作区中删除</li><li>git mv 移动或重命名工作区文件</li><li>git remote 用于管理远程仓库<ul><li>git remote：列出当前仓库中的远程仓库</li><li>git remote -v：列出当前仓库中已配置的远程仓库，并显示它们的 URL</li><li>git remote add &lt;remote_name&gt; &lt;remote_url&gt;：添加一个新的远程仓库，指定一个远程仓库的名称和 URL，将其添加到当前的仓库中。</li><li>git remote rename &lt;old_name&gt; &lt;new_name&gt;：将已配置的远程仓库重命名。</li><li>git remote remove <remote>：从当前仓库删除指定远程仓库</li><li>git remote set-url &lt;remote_name&gt; &lt;new_url&gt;：修改指定远程仓库的 URL</li><li>git remote show &lt;remote_name&gt;：显示指定远程仓库的详细信息，包括 URL 和跟踪分支</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git remote add miaomiao https://github.com/Ainavo/yutto.git</span><br><span class="line">git remote rename miaomaio wangwang</span><br><span class="line">git remote remove miaomiao</span><br><span class="line">git remote set-url miaomiao https://github.com/Ainavo/miaomaio.git</span><br><span class="line">git remote show miaomiao</span><br></pre></td></tr></table></figure><ul><li>git fetch 从远程获取代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch <span class="comment"># 从远程获取代码</span></span><br></pre></td></tr></table></figure><ul><li>git pull 拉取并合并远程 repo 的最新代码:git pull = git fetch + git merge</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line">git pull origin master:brantest <span class="comment">#将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>git push 将本地分支推送到远程并合并</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;  <span class="comment"># 如果本地分支名和远程分支名相同则可以忽略省略号</span></span><br><span class="line">git push --force-with-lease <span class="comment"># 强制推送（最小差异）</span></span><br></pre></td></tr></table></figure><h2 id="git-开发简单流程"><a class="markdownIt-Anchor" href="#git-开发简单流程"></a> Git 开发简单流程</h2><ul><li>首先，fork 一个想要贡献代码的 repo，然后 clone 到本地。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Ainavo/yutto.git  <span class="comment"># 还是以某个B站下载器为例</span></span><br></pre></td></tr></table></figure><img src="/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/fork%E5%88%AB%E4%BA%BArepo.png" class="" title="fork别人repo">  <img src="/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/fork%E7%AC%AC%E4%BA%8C%E6%AD%A5.png" class="" title="fork第二步">  <ul><li>git 创建一个新分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b miaomiao  <span class="comment"># 创建一个新分支叫 miaomiao，至于为什么要创建新分支--因为不能直接在 develop/master 等主分支直接提交</span></span><br><span class="line">git switch -c xxxx <span class="comment"># 同样创建一个新分支 xxxx，建议用这种</span></span><br><span class="line">git branch <span class="comment"># 查看所有本地分支</span></span><br></pre></td></tr></table></figure><ul><li>git 提交修改内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  <span class="comment"># 添加所有更改内容到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;miaomiaomiao&quot;</span> <span class="comment"># 将暂存区提交到本地仓库，形成一个新的版本，生成一个指定 commit ID 标识号</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="遇到的一些小问题"><a class="markdownIt-Anchor" href="#遇到的一些小问题"></a> 遇到的一些小问题</h2><ul><li>在与别人协作开发时，有时常常会因为别人先合入 repo，产生冲突，对于简单的冲突：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设目前处在 miaomiao 分支</span></span><br><span class="line">git checkout master  <span class="comment"># 以master为例，切入主分支</span></span><br><span class="line">git pull <span class="comment"># 拉取最新的 develop 代码</span></span><br><span class="line">git checkout miaomiao <span class="comment"># 切回 miaomiao 分支</span></span><br><span class="line">git merge master <span class="comment"># 合并 master 分支</span></span><br><span class="line">git push --force-with-lease <span class="comment"># 强制推送最小改变到远程分支</span></span><br></pre></td></tr></table></figure><ul><li>某些冲突太多，不能直接解决冲突(直接重组)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设目前处在 miaomiao 分支</span></span><br><span class="line">git checkout master  <span class="comment"># 以master为例，切入主分支</span></span><br><span class="line">git pull <span class="comment"># 拉取最新的 develop 代码</span></span><br><span class="line">git checkout miaomiao <span class="comment"># 切回 miaomiao 分支</span></span><br><span class="line">git reset --hard master <span class="comment"># 将 miaomiao 分支上的代码回退到 master 上</span></span><br><span class="line">git push --force-with-lease <span class="comment"># 强制推送最小改变到远程分支</span></span><br></pre></td></tr></table></figure><h2 id="git-命令速查表"><a class="markdownIt-Anchor" href="#git-命令速查表"></a> Git 命令速查表</h2><img src="/2023/07/24/Git-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8.jpg" class="" title="Git常用命令速查表"><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><ul><li><a href="https://git-scm.com/book/zh/v2">Git Book</a></li><li><a href="https://www.runoob.com/git/git-branch.html">Git 基本操作</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与指针</title>
      <link href="/2023/07/21/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
      <url>/2023/07/21/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>函数和指针！！！</p><span id="more"></span><h2 id="数组的定义和应用"><a class="markdownIt-Anchor" href="#数组的定义和应用"></a> 数组的定义和应用</h2><ul><li><p>数组的定义：</p><ul><li><p>&lt;类型&gt; 变量名[元素数量];</p></li><li><p>元素必须是整数</p></li><li><p>数组：是一种容器（存放东西的东西）</p></li><li><p>其中所有元素具有相同的数据类型</p></li><li><p>一旦创建，不能改变大小（const 类型）</p></li><li><p>数组中元素在内存中是连续依次排列的</p></li><li><p>数组的声明和初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> grades[<span class="number">100</span>];  <span class="comment">// 声明一个 100 个 sizeof(int) 的数组</span></span><br><span class="line"><span class="type">double</span> weight[<span class="number">20</span>]; <span class="comment">// 声明一个 20 个 sizeof(double) 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 定义数组 a 并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Notes：C99 中支持</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;[<span class="number">0</span>]=<span class="number">1</span>, [<span class="number">2</span>]=<span class="number">6</span>, <span class="number">8</span>&#125;; <span class="comment">//[n] 在初始化数据中给出定位；没定位的数据接在前面位置的后面，其余自动补零</span></span><br><span class="line">                               <span class="comment">// 适合构建稀疏数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组的大小：<code>sizeof(a) / sizeof(a[0])</code></p></li><li><p>注意事项：</p><ul><li>数组的赋值：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = a; <span class="comment">// 不可以，因为数组不能直接赋值，必须遍历赋值</span></span><br><span class="line">            <span class="comment">// int a[] 等价于 int *const a</span></span><br></pre></td></tr></table></figure></li><li>数组作为参数时：<ul><li>数组作为函数参数，往往必须再用另一个参数参入数组的长度</li><li>不能在 <code>a[]</code> 中 <code>[]</code> 给出数组的大小</li><li>不能用 <code>sizeof</code> 计算元素的个数</li></ul></li></ul></li><li><p>二维数组：</p><ul><li><code>int a[3][4]</code> 定义一个 3 行 4 列的整数数组；</li><li><code>a[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列；</li><li>注意：<code>a[i,j]</code>并不是表示第 <code>i</code> 行第 <code>j</code> 列，而是 <code>a[j]</code> (因为 <code>,</code> 是运算符，同时执行多个表达式)</li></ul></li><li><p>可变数组：</p><ul><li><code>Array array_create(int init_size);</code>：创建可变数组</li><li><code>void array_free(Array *a);</code>：回收数组</li><li><code>int array_size(const Array *a);</code>：数组大小</li><li><code>int *array_at(Array *a, int index);</code>：访问某个单元</li><li><code>void array_inflate(Array *a, int more_size);</code>：增加数组长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125; Array;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BLOCK_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可变数组</span></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>&#123;</span><br><span class="line">  Array a;</span><br><span class="line">  a.size = init_size;</span><br><span class="line">  a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(init_size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">  a-&gt;<span class="literal">NULL</span>;</span><br><span class="line">  a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问某个单元</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= a-&gt;size)&#123;</span><br><span class="line">      array_inflate(a, (index/BLOCK_SIZE + <span class="number">1</span>)*BLOCK_SZIE - a-&gt;size);  <span class="comment">//传进的a已经是个地址了，所以函数内部不需要&amp;取地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;a-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(more_size+a-&gt;size));</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; a-&gt;size; ++i)&#123;</span><br><span class="line">      p[i] = a-&gt;<span class="built_in">array</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">  a-&gt;<span class="built_in">array</span> = p;</span><br><span class="line">  a-&gt;size = more_size+a-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a = array_create(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, array_size(&amp;a));</span><br><span class="line">    *array_at(&amp;a, <span class="number">0</span>) = <span class="number">10</span>;  <span class="comment">// array_at 返回的是地址，因此直接*取地址中的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *array_at(&amp;a, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)</span><br><span class="line">            *array_at(&amp;a, cnt++) = number;</span><br><span class="line">    &#125;</span><br><span class="line">    array_free(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;  <span class="comment">// 不是字符串，因为没按字符串的形式做计算</span></span><br><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 是字符串，字符串在C中都以 \0 结尾（不显式）</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><ul><li>以 <code>0</code> 结尾的一串字符: <code>0</code> 和 <code>\0</code> 都是一样的，但是和<code>'0'</code>不同</li><li>以 <code>0</code> 标志字符串的结束，但它不是字符串的一部分：计算字符长度时，不包括 <code>0</code></li><li>字符以数组的形式存在，以数组或指针访问：更多以指针的形式访问</li></ul></li><li><p>字符串变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 只读的，不能写</span></span><br><span class="line"><span class="type">char</span> word[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> line[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 占位符 6 个字符，结尾是 0；</span></span><br><span class="line"><span class="comment">// 如果构造一个字符串--&gt;数组</span></span><br><span class="line"><span class="comment">// 如果处理一个字符串--&gt;指针</span></span><br></pre></td></tr></table></figure></li><li><p>字符串的输入和输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">string</span>);  <span class="comment">// scanf 读入一个单词（到空格、tab、回车为止）；scanf 同样不安全</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>char** a</code>:<code>a</code> 是一个指针，指向另一个指针，那个指针指向一个字符串</p></li><li><p>单字符的输入输出：</p><ul><li><code>int putchar(int c);</code> 向标准写入一个字符；返回写了几个字符，EOF(-1)表示写入失败</li><li><code>int getchar(void);</code> 从标准输入读入一个字符</li></ul></li><li><p><code>string.h</code> 字符串库</p><ul><li><p><code>strlen</code>：返回字符串长度，不含 <code>0</code>。</p></li><li><p><code>strcmp</code>：比较两个字符串：</p><ul><li><code>0</code>：s1 == s2</li><li><code>1</code>：s1 &gt; s2</li><li><code>-1</code>：s1 &lt; s2</li></ul></li><li><p>strcpy(char restrict dst, const char restrict src):拷贝 src–&gt;dst，restrict 表明 src 和 dst 不重叠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">mycopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span>&#123;</span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(src[idx])&#123;</span><br><span class="line">    dst[idx] = src[idx];</span><br><span class="line">    ++idx;</span><br><span class="line">  &#125;</span><br><span class="line">  dst[idx]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *rest = dst;</span><br><span class="line">  <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">    *dst = *src;</span><br><span class="line">    ++src;</span><br><span class="line">    ++dst;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> s1[] = <span class="string">&quot;abb&quot;</span>;</span><br><span class="line">  <span class="type">char</span> s2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  mycpy(s1, s2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *s1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>strchr：字符串找字符从左到右，返回指向字符的地址（如果找到第二个，则继续在返回的地址中找）</p></li><li><p>strrchr：字符串找字符从往右到左，返回指向字符的地址</p></li><li><p>strstr：字符串找字符串</p></li></ul></li></ul><h2 id="指针的定义和应用"><a class="markdownIt-Anchor" href="#指针的定义和应用"></a> 指针的定义和应用</h2><ul><li><p>指针的定义</p><ul><li>指针就是保存地址的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p = &amp;i; <span class="comment">// &amp; 取地址符；&amp;(a+b), &amp;(a++), &amp;(++a) 会报错 ==&gt; &amp; 右边只能是固定数</span></span><br><span class="line"><span class="type">int</span> *p, q; <span class="comment">// p 是一个指针，q 只是一个整型</span></span><br><span class="line"><span class="type">int</span>* p, q; <span class="comment">// p 是一个指针，q 只是一个整型</span></span><br></pre></td></tr></table></figure><ul><li>指针作为参数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">6</span>;</span><br><span class="line">  f(&amp;i);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针的应用</p><ul><li>指针的运算：<ul><li><code>*(p+1)</code>、<code>*(p++)</code>、<code>*(p--)</code></li><li><code>*p++</code>:<ul><li>取出 <code>p</code> 所指的数据，完事顺便把 <code>p</code> 移到下个位置</li><li><code>*</code>优先级虽然高，但是没有 <code>++</code> 高</li><li>常用于数组类的连续空间操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ac[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="type">char</span> *p = &amp;ac[<span class="number">0</span>]; <span class="comment">// 等价 char *p = ac;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(ac)/<span class="keyword">sizeof</span>(ac[<span class="number">0</span>]); ++<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(p=ac; *p=<span class="number">-1</span>; ++p)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>指针的比较：<ul><li><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code> 都可以对指针进行比较</li><li>比较它们在内存中的地址</li><li>数组中的单元地址肯定是线性递增的</li></ul></li><li><code>NULL</code>:表示<code>0</code>地址</li><li>指针的类型不能相互赋值（<code>double</code> 和 <code>int</code> ）</li><li>指针类型转换<ul><li>void* 表示不知道指针指向什么东西的指针<ul><li>计算时与 char* 相同(但不相通)</li></ul></li><li>指针也可以转换类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=&amp;i;</span><br><span class="line"><span class="type">void</span> *q=(<span class="type">void</span>*)p;  <span class="comment">// 这并没有改变 p 所指的变量类型，而后让后人用不同的眼光看它所指代的变量--“我不当你是 int，我认为你就是个 void”</span></span><br></pre></td></tr></table></figure></li></ul></li><li>指针的用途<ul><li>需要传入较大的数据时用作参数</li><li>传入数组后对数组做操作</li><li>函数返回不止一个结果：需要用函数修改的不止一个变量</li><li>动态申请内存</li></ul></li><li><strong>动态内存分配：malloc 返回的是 void*，需要强制类型转换(申请的是字节)</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> *a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 申请内存</span></span><br><span class="line"><span class="built_in">free</span>(a); <span class="comment">// 记得释放</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="指针和数组的关系"><a class="markdownIt-Anchor" href="#指针和数组的关系"></a> 指针和数组的关系</h2><ul><li><p>数组是特殊的指针：</p><ul><li>数组变量本身表达地址：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = a;  <span class="comment">// 无需用 &amp; 取地址符</span></span><br><span class="line"><span class="type">int</span> *q = &amp;a[<span class="number">0</span>]; <span class="comment">// 对于数组单元变量，需要 &amp; 取地址</span></span><br></pre></td></tr></table></figure><ul><li><code>a = &amp;a[0]</code> 等价的</li><li><code>[]</code> 运算符可以对数组做，也可以对指针做：<ul><li>p[0] &lt;==&gt; a[0]:等价的</li></ul></li><li><code>*</code> 运算符可以对指针做，也可以多数组做：<ul><li>*a = 25;</li></ul></li></ul></li><li><p>指针与 <code>const</code>：</p><ul><li>若指针是 <code>const</code>：表示一旦得到某个变量的地址，不能再指向其他变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;i;  <span class="comment">// q是const</span></span><br><span class="line">*q = <span class="number">26</span>;  <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><ul><li>所指 <code>const</code>：表示不能通过这个指针去修改那个变量（并不能使指向那个变量成为 <code>const</code>）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>;  <span class="comment">// ERROR! (*p) 是 const</span></span><br><span class="line">i = <span class="number">26</span>;  <span class="comment">// OK</span></span><br><span class="line">p = &amp;j;  <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// i 可以变；p 可以变；*p 可以变</span></span><br></pre></td></tr></table></figure><ul><li>关键：判断 <code>const</code> 和 <code>*</code> 的位置关系：<code>const</code> 在<code>*</code>前<code>*p</code>不能被修改；<code>const</code> 在<code>*</code>后，<code>p</code>不能被修改。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;i;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p2 = &amp;i;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3 = &amp;i;</span><br><span class="line"><span class="comment">// 技巧：主要看 const 修饰的是 *p，还是 p ==&gt; 修饰 *p 就是 p 指向的内容不能改变，修饰 p，p 则不能的改变</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/2023/07/21/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/07/21/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>结构体的使用、和指针结合的结构体</p><span id="more"></span><h2 id="c-语言结构体知识点"><a class="markdownIt-Anchor" href="#c-语言结构体知识点"></a> C 语言结构体知识点</h2><ul><li><p>定义结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">  &#125;;   <span class="comment">// (声明?定义？)一个结构体 Cat</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">&#125; cat1, cat2;  <span class="comment">// 定义结构体变量的另一种形式</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">float</span> score;</span><br><span class="line">&#125; cat1, cat2;  <span class="comment">// 既有声明也有定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结构体变量的定义和初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">tabby</span>;</span>  <span class="comment">// 定义一个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">tabby_miao</span> =</span> &#123;<span class="string">&#x27;Nyakku&#x27;</span>, <span class="number">8</span>, <span class="number">100</span>&#125;;  <span class="comment">// 初始化结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">tabby</span> =</span> &#123;.name=<span class="string">&quot;xxx&quot;</span>, .age=<span class="number">10</span>&#125;;  <span class="comment">// 另一种初始化方式</span></span><br></pre></td></tr></table></figure></li><li><p>访问结构体成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">tabby</span>;</span></span><br><span class="line">tabby.name = <span class="string">&quot;Nyakku&quot;</span>; <span class="comment">// . 用来访问结构体内的变量</span></span><br></pre></td></tr></table></figure></li><li><p>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> *<span class="title">p</span>;</span>  <span class="comment">// 定义一个 Cat 类型的</span></span><br><span class="line">p = &amp;tabby <span class="comment">//p 指向 tabby</span></span><br><span class="line">p-&gt;name = <span class="string">&quot;Nyakku&quot;</span>  <span class="comment">// -&gt; 可以访问指针类型结构体的内部成员</span></span><br></pre></td></tr></table></figure></li><li><p>补充：关于 C 语言中声明(Definition)和定义(Declaration)的区别</p><ul><li>定义：指在程序中为一个实体(变量、函数、结构体等)分配空间。在定义时，编译器会为其分配空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// 定义一个整型变量 a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;  <span class="comment">// 定义一个函数</span></span><br></pre></td></tr></table></figure><ul><li>声明：是指在程序中声明一个实体的存在，但不为其分配内存空间或实现其功能。声明告诉编译器该实体的类型和名称，并使得其他地方可以引用该实体。声明可以出现在函数内部或外部，以及头文件中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// 声明外部变量 a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体与指针数组的结合使用"><a class="markdownIt-Anchor" href="#结构体与指针数组的结合使用"></a> 结构体与指针数组的结合使用</h2><ul><li>结构体和数组有点像：<ul><li>要访问整个结构体，直接用结构变量的名字</li><li>对于整个结构，可以做赋值、取地址、也可以传递参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (<span class="keyword">struct</span>)&#123;<span class="number">5</span>, <span class="number">10</span>&#125;;  <span class="comment">//相当于 p1.x = 5, p1.y = 10</span></span><br><span class="line">p1 = p2; <span class="comment">// 相当于 p1.x = p2.x; p1.y = p2.y</span></span><br></pre></td></tr></table></figure><ul><li>和数组不同的点是：结构变量的名字并不是结构变量的地址，所以必须用&amp;运算符号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;tabby;</span><br></pre></td></tr></table></figure></li><li>输入结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point p)</span> &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.x);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.y);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p.x, &amp;p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指向结构体的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">&#125; today;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;mydate;</span><br><span class="line">(*p).month = <span class="number">12</span>;  <span class="comment">// .优先级高于 *</span></span><br><span class="line">p-&gt;month = <span class="number">12</span>; <span class="comment">// 用 -&gt; 表示指针所指的结构变量中的成员</span></span><br></pre></td></tr></table></figure><ul><li>结构体和指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  getStruct(&amp;y);  <span class="comment">// 结构体传入地址必须用&amp;</span></span><br><span class="line">  output(y);</span><br><span class="line">  output(*getStruct(&amp;y)); <span class="comment">// getStruct 返回指针</span></span><br><span class="line">  print(getStruct(&amp;y)); <span class="comment">// print 输入指针</span></span><br><span class="line">  getStruct(&amp;y)-&gt;x = <span class="number">0</span>; <span class="comment">// getStruct 返回指针</span></span><br><span class="line">  *getStruct(&amp;y).x = <span class="number">0</span>; <span class="comment">// * 指针 指向所指的内容</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *)</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;x);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  print(<span class="string">&quot;%d\n&quot;</span>, p-&gt;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2005</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2005</span>&#125;</span><br><span class="line">&#125;;  <span class="comment">// 定义一个100大小的 struct date 的数组</span></span><br></pre></td></tr></table></figure><ul><li><p>类型定义：自定义数据类型(typedef)</p><ul><li>typedef 用来声明一个已有的数据类型的新名字，例如：<code>typedef int miamia</code></li><li>声明之后，<code>miamia</code> 可以替代 <code>int</code></li><li>与结构体相关用法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AData</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> month;</span><br><span class="line">  <span class="type">int</span> day;</span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line">&#125; Date;  <span class="comment">// 简化复杂的结构体，用Date代替结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">int64_t</span> i = <span class="number">1000000000000</span>;</span><br><span class="line">Date d = &#123;<span class="number">8</span>, <span class="number">3</span>, <span class="number">2023</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言程序设计中一些值得注意的点</title>
      <link href="/2023/07/15/C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
      <url>/2023/07/15/C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><em>Notes</em>:参考课程<a href="https://space.bilibili.com/1355742754">&lt;&lt;浙大瓮恺 C 语言程序设计&gt;&gt;</a></p><span id="more"></span><ul><li><p>scanf() 中格式字符中的字符是必须输入的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;print %d&quot;</span>, &amp;a) <span class="comment">//终端中输入必须是 &quot;print xxx&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>运算符和算子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + c <span class="comment">// a, b, c 算子； =, + 运算符；</span></span><br></pre></td></tr></table></figure></li><li><p>运算符优先级</p><table><thead><tr><th>优先级</th><th>运算符</th><th>运算</th><th>结合关系</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>+</td><td>单目不变</td><td>自右向左</td><td>a*+b</td></tr><tr><td>1</td><td>-</td><td>单目取负</td><td>自右向左</td><td>a*-b</td></tr><tr><td>2</td><td>*</td><td>乘</td><td>自左向右</td><td>a*b</td></tr><tr><td>2</td><td>/</td><td>除</td><td>自左向右</td><td>a/b</td></tr><tr><td>2</td><td>%</td><td>取余</td><td>自左向右</td><td>a%b</td></tr><tr><td>3</td><td>+</td><td>加</td><td>自左向右</td><td>a+b</td></tr><tr><td>3</td><td>-</td><td>减</td><td>自左向右</td><td>a-b</td></tr><tr><td>4</td><td>=</td><td>赋值</td><td>自右向左</td><td>a=b</td></tr></tbody></table></li><li><p>a++ 和 ++a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++<span class="number">1</span>; <span class="comment">// 返回结果 2；并实现 +1 功能；</span></span><br><span class="line"><span class="number">1</span>++; <span class="comment">// 返回结果 1；并实现 +1 功能；</span></span><br></pre></td></tr></table></figure></li><li><p>循环 tips：</p><ul><li>如果有固定次数，用 for 循环： for(; ; 😉</li><li>如果必须执行一次：用 do_while 循环</li><li>其他情况用 while 循环</li></ul></li><li><p>跳出循环：</p><ul><li>break：跳出循环</li><li>continue：跳出本轮循环，继续下一轮</li><li>goto：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    ....</span><br><span class="line">    <span class="keyword">goto</span> out:</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>辗转相除法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果b等于0，计算结束，a就是最大公约数；</span></span><br><span class="line"><span class="comment">// 否则，计算a除以b的余数，让a等于b，b等于那个余数；</span></span><br><span class="line"><span class="comment">// 构建循环体。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, temp=%d\n&quot;</span>, a, b, temp);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a与b的最大公约数为 %d&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数字类型</p><ul><li>类型名称：int、long、double</li><li>输入输出时的格式化：%d、%ld、%lf</li><li>所表达数的范围：char &lt; short &lt; int &lt; float &lt; double</li><li>内存中所占据的大小：1 个字节到 16 个字节</li><li>内存中的表达形式：二进制数（补码）、编码</li></ul></li><li><p>sizeof：一个 int 表达一个寄存器的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 1字节（8比特）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>)); <span class="comment">// 2字节</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 取决于编译器（CPU）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>)); <span class="comment">// 取决于编译器（CPU）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long long) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)); <span class="comment">// 8字节</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补码的意义：补码和原码相加可以得到一个溢出的 0</p></li><li><p>整数的范围：对于一个字节（8 位）可以表达的是：</p><ul><li>00000000~11111111</li><li>11111111<sub>10000000–&gt;-1</sub>-128(作为补码来看)</li><li>00000001~01111111–&gt; 1~127</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%d, i=%d\n&quot;</span>, c, i); <span class="comment">// c=-1, i=255</span></span><br><span class="line">    <span class="comment">// 11111111</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000000 11111111</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>char(1 字节):-128~127</li><li>short(2):-32768~32767</li><li>int:取决于编译器（CPU），通常意义上是&quot;1 个字&quot; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>long(4 字节)</li><li>long long(8 字节)</li></ul></li><li><p>unsigned:表示纯二进制(主要为了做移位)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">255</span>;</span><br><span class="line">     <span class="type">int</span> i =<span class="number">255</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;c=%d, i=%d\n&quot;</span>, c, i);</span><br><span class="line">     <span class="comment">// 00000000 - 11111111 0~255 正常：-128~127</span></span><br><span class="line">     <span class="comment">// 00000000 00000000 00000000 11111111</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>整数输入输出：int 和 long long</p><ul><li>%d:int</li><li>%u:unsigned</li><li>%ld:long long</li><li>%lu: unsigned long long</li></ul></li><li><p>浮点数类型：</p><table><thead><tr><th>类型</th><th>字长</th><th>范围</th><th>有效数字</th><th>scanf</th><th>printf</th></tr></thead><tbody><tr><td>float</td><td>32</td><td>±(1.2x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>38</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>~3.40x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>38</mn></msup></mrow><annotation encoding="application/x-tex">10^{38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>), 0, ±inf, nan</td><td>7</td><td>%f</td><td>%f, %e(科学计数)</td></tr><tr><td>double</td><td>64</td><td>±(2.2x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>308</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-308}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>~1.79x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>308</mn></msup></mrow><annotation encoding="application/x-tex">10^{308}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>), 0, ±inf, nan</td><td>15</td><td>%lf</td><td>%f, %e(科学计数)</td></tr></tbody></table></li><li><p>超过范围的浮点数：</p><ul><li>printf 输出 inf 表示无穷大</li><li>printf 输出 nan 表示不存在的浮点数</li></ul></li><li><p>浮点运算的精度</p><ul><li>带小数点的字面量意思是 double 而非 float</li><li>float 需要用 f 或 F 后缀来表明身份<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c;</span><br><span class="line">a = <span class="number">1.345f</span>;</span><br><span class="line">b = <span class="number">1.123f</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2.468</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不相等！c=%.10f, 或%f\n&quot;</span>, c, c)  <span class="comment">// f1 == f2 可能失败 ； fabs(f1-f2) &lt; 1e-12 验证;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>浮点数的内部表达：</p><ul><li>sign(1 bit)：符号位</li><li>exponent(11 bit)：指数位</li><li>fraction(52 bit)：小数位</li></ul></li><li><p>字符类型</p><ul><li>char(字符)：printf 和 scanf 用%c 输入输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%d&quot;</span>, a);  <span class="comment">// 1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c&quot;</span>, a);  <span class="comment">// 49 ASIIC 码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>逃逸字符：用来表达无法打印出来的控制字符或者特殊字符，他由一个反斜杠&quot;&quot;开头，后面跟上另一个字符，这两个字符合起来，组成一个字符。</p><table><thead><tr><th>字符</th><th>意义</th><th>字符</th><th>意义</th></tr></thead><tbody><tr><td>\b</td><td>回退一格</td><td>&quot;</td><td>双引号</td></tr><tr><td>\t</td><td>到下一个表格位</td><td>'</td><td>单引号</td></tr><tr><td>\n</td><td>换行</td><td>\</td><td>反斜杠本身</td></tr><tr><td>\r</td><td>回车</td><td></td><td></td></tr></tbody></table></li><li><p>自动类型转换：</p><ul><li>当运算符两边出现不一样类型时，会自动转换成较大（范围大）的类型；</li><li>char–&gt;short–&gt;int–&gt;long–&gt;long long</li><li>int–&gt;float–&gt;double</li><li>注：<ul><li>对于 printf，任何小于 int 类型的都会转换成 int；float 会被转换成 double；</li><li>对于 scanf 则不会，要输入 short，需要 %hd</li></ul></li></ul></li><li><p>强制转换：优先级高于四则运算</p><ul><li>(类型)值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)<span class="number">32.3</span></span><br><span class="line">(<span class="type">short</span>)<span class="number">32</span></span><br></pre></td></tr></table></figure></li><li>注意小的变量不总能表达大的变量</li></ul></li><li><p>逻辑类型(bool)和逻辑运算</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td>!a</td><td>如果 a 是 true 结果就是 false；如果 a 是 false，结果就是 true；</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>a &amp;&amp; b</td><td>如果 a 和 b 都是 true，结果就是 true；否则就是 false；</td></tr><tr><td>||</td><td>逻辑或</td><td>a || b</td><td>如果 a 和 b 中有一个是 true，结果为 true；两个都为 false，结果为 false；</td></tr></tbody></table></li><li><p>运算符优先级</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>（）</td><td>从左到右</td></tr><tr><td>2</td><td>! + - ++ –</td><td>从右到左（单目的+和-）</td></tr><tr><td>3</td><td>_ / %</td><td>从左到右</td></tr><tr><td>4</td><td>+ -</td><td>从左到右</td></tr><tr><td>5</td><td>&lt;&lt;= &gt;&gt;=</td><td>从左到右</td></tr><tr><td>6</td><td>== !=</td><td>从左到右</td></tr><tr><td>7</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>8</td><td>||</td><td>从左到右</td></tr><tr><td>9</td><td>= += -= _= /= %=</td><td>从左到右</td></tr></tbody></table></li><li><p>条件运算符：自右向左</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m&lt;n ?  a:a+<span class="number">5</span> <span class="comment">// (条件) ? a : b</span></span><br></pre></td></tr></table></figure></li><li><p>逗号运算符：所有运算符中优先级最低的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">10</span>; i&lt;j; i++, j--) <span class="comment">// 基本上只有 for 条件会用到</span></span><br></pre></td></tr></table></figure></li><li><p>本地变量</p><ul><li>生存期：什么时候这个变量出现了，到什么时候它消亡了</li><li>作用域：在代码什么范围内可以访问这个变量（这个变量起作用）</li><li>对于本地变量，这两个问题答案是统一的：大括号内–块<ul><li>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</li><li>块外面定义的变量在里面仍然有效</li><li>快里面定义了和外面同名的变量则掩盖了外面的</li><li>不能在一 个块中定义同名变量</li></ul></li></ul></li><li><p>函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>; <span class="comment">// 与函数名称相同</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 无参数</span></span><br></pre></td></tr></table></figure></li><li><p>数组的定义</p><ul><li>&lt;类型&gt; 变量名[元素数量]；</li><li>int grades[100];</li><li>double weight[20];</li></ul></li><li><p>元素必须是整数；</p><ul><li>数组：是一种容器(存放东西的东西)</li><li>其中所有元素都具有相同的数据类型；</li><li>一旦创建，不能改变大小；</li><li>*(数组中元素在内存中是连续依次排列的) -数组初始化：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>C99 中支持：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;[<span class="number">0</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>用[n]在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面，其余位置自动补零</li><li>也可以不给出数组大小，让编译器算</li><li>适合初始数据稀疏的数组</li></ul></li><li><p>数组的大小：sizeof(a)/sizeof(a[0])</p></li><li><p>数组的赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,&#125;;</span><br><span class="line"><span class="type">int</span> b[] = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><ul><li>数组不能直接赋值</li><li>把一个数组元素交给另一个数组，必须采用遍历</li></ul></li><li><p>数组作为函数的参数时：</p><ul><li>数组作为函数参数，往往必须再用另一个参数来传入数组的长度</li><li>不能在 a[] 中 [] 给出数组大小</li><li>不能利用 sizeof 计算元素个数</li></ul></li><li><p>二维数组：</p><ul><li>a[i][j]是一个 int：表示第 i 行第 j 列</li><li>a[i, j]错误表达：表示 a[j] (&quot;<strong>,</strong>&quot;运算符)</li><li>列数必须有，行数可以省略</li></ul></li><li><p>运算符 &amp;</p><ul><li>scanf(&quot;%d, &amp;d)中&amp;：获取变量的地址</li><li>&amp;(a+b), &amp;(a++), &amp;(++a) 都会报错， &amp;右边只能是固定数</li></ul></li><li><p>指针：就是保存地址的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p, q;  <span class="comment">// p是一个指针，指向int 同下；q不是一个指针；</span></span><br><span class="line"><span class="type">int</span> *p, q; <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure></li><li><p>指针作为参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">    f(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问地址变量*：</p><ul><li>*是一个单目运算符，用来访问指针的值表示的地址上的变量</li><li>可以作为左值或右值：<ul><li>int k = *p</li><li>*p = k+1</li></ul></li></ul></li><li><p>指针应用场景：</p><ul><li>交换两个值</li><li>函数返回运算状态，结果通过指针返回</li></ul></li><li><p>指针最常见错误：指针未指向地址，就赋值</p></li><li><p>以下四种函数原型是等价的：</p><ul><li>int sum(int *ar, int n);</li><li>int sum(int *, int);</li><li>int sum(int ar[], int n);</li><li>int sum(int[], int);</li></ul></li><li><p>数组变量就是特殊的指针：</p><ul><li>数组变量本身表达地址：<ul><li>int a[10]; int*p = a; //无需用&amp;取地址</li><li>但是数组的单元表达的是变量，需要用&amp;去取地址</li><li>a == &amp;a[0]</li></ul></li><li>[] 运算符可以对数组做，也可以对指针做：<ul><li>p[0]&lt;==&gt;a[0]</li></ul></li><li>*运算符可以对指针做，也可以对数组做：<ul><li>*a = 25;</li></ul></li><li>数组变量是 const 指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] &lt;==&gt; <span class="type">int</span> * <span class="type">const</span> a <span class="comment">// 因此两个数组间不能直接赋值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>指针与 const：</p><ul><li>指针是 const：表示一旦得到了某个变量的地址，不能再指向其他变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;i; <span class="comment">// q 是 const</span></span><br><span class="line">*q = <span class="number">26</span>； <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li>所指是 const：表示不能通过这个指针去修改那个变量（并不能使得那个变量成为 const）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//EEROR! (*p)是const</span></span><br><span class="line">i = <span class="number">26</span>; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j; <span class="comment">//OK</span></span><br><span class="line"><span class="comment">// i 可以变；p 可以变；*p 不可以变；</span></span><br></pre></td></tr></table></figure><ul><li>例子：判断 const 和*的位置关系–const 在*前 *p 不能被修改；const 在*后 p(地址不能被修改)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;i;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p2 = &amp;i;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3 = &amp;i;</span><br><span class="line"><span class="comment">// 技巧：主要看 const 修饰的是 *p，还是 p</span></span><br></pre></td></tr></table></figure></li><li><p>指针的计算：</p><ul><li>*(p+1)、*(p++)、*(p–)</li><li>*p++:<ul><li>取出 p 所指的那个数据，完事顺便把 p 移到下个位置</li><li>*的优先级虽然高，但是没有++高</li><li>常用于数组类的连续空间操作</li><li>在某些 CPU 上，这可以直接被翻译成一条汇编指令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ac[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p = &amp;ac[<span class="number">0</span>]; <span class="comment">// 等价 char *p = ac;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ac)/<span class="keyword">sizeof</span>(ac[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=ac; *p=<span class="number">-1</span>; p++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指针比较：<ul><li>&lt;, &lt;=, ==, &gt;, &gt;=, != 都可以对指针进行比较</li><li>比较它们在内存中的地址</li><li>数组中的 单元地址肯定是线性递增的</li></ul></li><li>0 地址：NULL 表示 0 地址</li><li>指针的类型不能相互赋值</li><li>指针类型转换<ul><li>void* 表示不知道指针指向什么东西的指针<ul><li>计算时与 char*相同(但不相通)</li></ul></li><li>指针也可以转换类型<ul><li>int *p = &amp;i;void*q =(void*) p;</li><li>这并没有改变 p 所指的变量类型，而是让后人用不同的眼光通过 p 看它所指的变量–我不再当你是 int，我认为你就是个 void</li></ul></li></ul></li><li>指针的用途：<ul><li>需要传入较大的数据时用作参数</li><li>传入数组后对数组做操作</li><li>函数返回不止一个结果<ul><li>需要用函数来修改不止一个变量</li></ul></li><li>动态申请内存</li></ul></li></ul></li><li><p>动态内存分配：malloc 返回的是 void*，需要强制类型转换(申请的是字节)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><ul><li>free():释放内存</li></ul></li><li><p>字符数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;; <span class="comment">//不是C语言字符串，因为不能用字符串的方式做计算</span></span><br><span class="line"><span class="type">char</span> word[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure></li><li><p>字符串：</p><ul><li>以 0（整数 0）结尾的一串字符<ul><li>0 或’\0’是一样的，但是和’0’不同</li></ul></li><li>0 标志字符串的结束，但它不是字符串的一部分<ul><li>计算字符串长度的时候不包括这个 0</li></ul></li><li>字符串以数组形式存在，以数组或指针的形式访问<ul><li>更多是以指针的形式</li></ul></li><li>string.h 有很多处理字符串的函数</li></ul></li><li><p>字符串变量</p><ul><li>char *str = “Hello”; // 只读的，不能写</li><li>char word[] = “Hello”;</li><li>char line[10] = “Hello”; // 占位 6 个字符，结尾是 0</li><li>如果要构造一个字符串–&gt;数组</li><li>如果要处理一个字符串–&gt;指针</li></ul></li><li><p>字符串输入和输出</p><ul><li>char string[8];</li><li>scanf(“%s”, string); //scanf 读入一个单词（到空格、tab、回车为止）；scanf 不安全；</li><li>printf(“%s”, string);</li></ul></li><li><p>char **: a 是一个指针，指向另一个指针，那个指针指向一个字符串</p></li><li><p>char [][]</p></li><li><p>程序参数：</p><ul><li>int main(int argc, char const* argv[])</li><li>argv[0] 是命令本身</li></ul></li><li><p>单字符的输入输出：</p><ul><li>int putchar(int c); // 向标准写入一个字符；返回写了几个字符，EOF(-1)表示写入失败</li><li>int getchar(void); // 从标准输入读入一个字符</li></ul></li><li><p>string.h</p><ul><li><p>strlen:返回字符串长度，不含 0；</p></li><li><p>strcmp：比较两个字符串：</p><ul><li>0：s1 == s2</li><li>1：s1 &gt; s2</li><li>-1: s1 &lt; s2</li></ul></li><li><p>strcpy(char *restrict dst, const char *restrict src)：拷贝 src–&gt;dst;restrict 表明 src 和 dst 不重叠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">mycpy</span><span class="params">(<span class="type">char</span>* dst, <span class="type">const</span> <span class="type">char</span> *src)</span>&#123;</span><br><span class="line">    &lt;!-- <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(src[idx])&#123;</span><br><span class="line">        dst[idx] = src[idx];</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    dst[idx] = <span class="string">&#x27;\0&#x27;</span>; --&gt; <span class="comment">// 数组版本</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *rest = *dst;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        *dst = *src;</span><br><span class="line">        src++;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    mycpy(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>strcat：</p></li><li><p>strchr：字符串找字符从左往右，返回指向字符的地址（如果找第二个则，继续在返回的地址中找）</p></li><li><p>strrchr：字符串找字符从右往左，返回指向字符的地址</p></li><li><p>strstr：字符串中找字符串</p></li></ul></li><li><p>枚举：enum 枚举类型名字 {名字 0, 名字 1, 名字 2, …};</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>RED, YELLOW, GREEN&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结构类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种形式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x,</span><br><span class="line">    <span class="type">int</span> y</span><br><span class="line">&#125; p1, p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piont</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x,</span><br><span class="line">    <span class="type">int</span> y</span><br><span class="line">&#125; p1, p2; <span class="comment">// 既声明有定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span> &#123;<span class="number">7</span>， <span class="number">31</span>， <span class="number">2023</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">miao</span> =</span> &#123;.month=<span class="number">7</span>, .year=<span class="number">2023</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>结构跟数组有点像：</p><ul><li>要访问整个结构，直接用结构变量的名字</li><li>对于整个结构，可以做赋值、取地址、也可以传递给函数参数<ul><li>p1=(struct point){5, 10}; //相当于 p1.x=5, p1.y=10</li><li>p1 = p2; // 相当于 p1.x = p2.x; p1.y = p2.y;</li></ul></li></ul></li><li><p>和数组不同的点是：结构变量的名字并不是结构变量的地址，必须用&amp;运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></table></figure></li><li><p>输入结构：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> piont p)</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p.y);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p.x, &amp;p.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指向结构的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strcut date &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; myday;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday;</span><br><span class="line">(*p).month = <span class="number">12</span>; <span class="comment">// .优先级高于 *;</span></span><br><span class="line">p-&gt;month = <span class="number">12</span>;  <span class="comment">// 用-&gt;表示指针所指的结构变量中的成员</span></span><br></pre></td></tr></table></figure></li><li>结构体和指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">y</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    getStruct(&amp;y);</span><br><span class="line">    output(y);</span><br><span class="line">    output(*getStruct(&amp;y));</span><br><span class="line">    print(getStruct(&amp;y));</span><br><span class="line">    getStruct(&amp;y)-&gt;x = <span class="number">0</span>;</span><br><span class="line">    *getStruct(&amp;y) = (<span class="keyword">struct</span> point)&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getStruct</span><span class="params">(<span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2005</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2005</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>类型定义：自定义数据类型(typedef)</p><ul><li>typedef 用来声明一个已有数据类型的新名字比如：typedef int Length；</li><li>声明之后，Length 就可以替代 int</li><li>与结构体相关用法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; Date;  <span class="comment">// 简化了复杂的结构体，用 Date 代替 结构体</span></span><br><span class="line"><span class="type">int64_t</span> i = <span class="number">1000000000000</span>;</span><br><span class="line">Date d = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2005</span>&#125;; <span class="comment">// 简单又高效!!!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>联合 union:共同使用一个空间</p></li><li><p>全局变量：</p><ul><li>定义在函数外面的变量是全局变量</li><li>全局变量具有全局的生存期和作用域<ul><li>它们和任何函数都无关</li><li>在任何函数内部都可以使用它们</li></ul></li><li>初始化：没做初始化的全局变量会得到 0 值；指针会得到 NULL 值</li><li>只能用编译时刻已知的值来初始化全局变量</li><li>它们的初始化发生在 main 函数前</li></ul></li><li><p>静态本地变量：static [数据类型] name;</p><ul><li>实际上是特殊的全局变量</li><li>位于相同的内存区域</li><li>今天本地变量具有全局生存期，在函数内的局部作用域：<ul><li>static 在这里的意思是局部作用域(本地可访问)</li></ul></li></ul></li><li><p>返回指针的函数：</p><ul><li>返回本地变量的地址是危险的</li><li>返回全局变量或者静态本地变量的地址是安全的</li><li>返回在函数内的 malloc 的内存是安全的，但是容易造成问题</li><li>最好的做法是传入指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);  <span class="comment">// 12</span></span><br><span class="line">    g();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);  <span class="comment">// 24 p地址中的内容被覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;  <span class="comment">// 不好，容易出错；正确做法：传入指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>预编译处理指令</p><ul><li>#开头是预编译指令</li><li>不是 C 语言的成分，但是 C 语言离不开他们</li><li>#define 用来定义一个宏： #define PI 3.14159 // 不能加 ;，因为不是 C 的语句</li><li>预定义宏：<ul><li>__LINE__</li><li>__FILE__</li><li>__DATE__</li><li>__TIME__</li><li>__STDC__</li></ul></li></ul></li><li><p>带参数的宏：所有用到参数的地方都要有括号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG(x) ((x)*3.14)</span></span><br></pre></td></tr></table></figure></li><li><p>多个.c 文件：</p><ul><li>main()里的代码太长了适合分成几个函数</li><li>一个源码文件太长了适合分成几个文件</li><li>两个独立的源码文件不能编译成可执行文件</li></ul></li><li><p>头文件：</p><ul><li>把函数原型放到一个头文件（以.h 结尾）中，在需要调用这个函数的原代码文件（.c 文件）中 #include 这个头文件，就能让编译器在编译的时候知道函数原型。</li><li>#include 有两种形式指出要插入的文件<ul><li>&quot;&quot;要求编译器首先在当前目录（.c 所在目录）寻找这个文件，如果没有，到编译器指定的目录去找</li><li>&lt;&gt;让编译器只在指定的目录下找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪</li><li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li></ul></li><li><p>#include 误区：</p><ul><li>#include 不是用来引入库的</li><li>stdio.h 只有 printf 原型，printf 的代码再另外的地方，某个.lib(Windows)或.a(Unix)中。</li><li>现在的 C 语言编译器默认会引入所有的标准库</li><li>#include &lt;stdio.h&gt; 只是为了让编译器知道 printf 函数的原型，保证调用时给出的参数值是正确的类型</li></ul></li><li><p>声明 extern int i; // 变量的声明</p><ul><li>声明是不会产生代码的东西<ul><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li>inline 函数</li></ul></li><li>定义是产生代码的东西</li><li>只有声明可以被放在头文件中<ul><li>是规则不是法律</li></ul></li><li>否则会造成一个项目多个编译单元里有重名的实体<ul><li>某些编译器允许几个编译单元中存在着同名的函数或者用 weak 修饰符来强调这种存在</li></ul></li></ul></li><li><p>标准头文件结构(解决宏重复定义)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAX_H</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>格式化输入输出</p><ul><li><p>printf</p><ul><li>%[flags][width][.prec][hIL]type</li></ul><table><thead><tr><th>Flag</th><th>含义</th><th>width 或 prec</th><th>含义</th><th>类型修饰</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>左对齐</td><td>number</td><td>最小字符数</td><td>hh</td><td>单个字节</td></tr><tr><td>-</td><td>在前面放+或-</td><td>*</td><td>下一个参数是字符数</td><td>h</td><td>short</td></tr><tr><td>(space)</td><td>正数留空</td><td>.number</td><td>小数点后的位数</td><td>I</td><td>long</td></tr><tr><td>0</td><td>0 填充</td><td>.*</td><td>下一个参数是小数点后的位数</td><td>II</td><td>long long</td></tr><tr><td></td><td></td><td></td><td></td><td>L</td><td>long double</td></tr></tbody></table><table><thead><tr><th>type</th><th>用于</th><th>type</th><th>用于</th></tr></thead><tbody><tr><td>i 或 d</td><td>int</td><td>g</td><td>float</td></tr><tr><td>u</td><td>unsigned int</td><td>G</td><td>float</td></tr><tr><td>o</td><td>八进制</td><td>a 或 A</td><td>十六进制的浮点数</td></tr><tr><td>x</td><td>十六进制</td><td>C</td><td>char</td></tr><tr><td>X</td><td>字母大写的十六进制</td><td>s</td><td>字符串</td></tr><tr><td>f 或 F</td><td>float,6</td><td>p</td><td>指针</td></tr><tr><td>e 或 E</td><td>指数</td><td>n</td><td>读入/写入的个数</td></tr></tbody></table></li><li><p>scanf</p><ul><li>%[flag]type</li></ul><table><thead><tr><th>flag</th><th>含义</th><th>flag</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>跳过</td><td>I</td><td>long, double</td></tr><tr><td>数字</td><td>最大字符数</td><td>II</td><td>long long</td></tr><tr><td>hh</td><td>char</td><td>L</td><td>long double</td></tr><tr><td>h</td><td>short</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>type</th><th>用于</th><th>type</th><th>用于</th></tr></thead><tbody><tr><td>d</td><td>int</td><td>a, e, f, g</td><td>float</td></tr><tr><td>i</td><td>整数，可能为十六进制或者八进制</td><td>c</td><td>char</td></tr><tr><td>u</td><td>unsigned int</td><td>s</td><td>字符串（单词）</td></tr><tr><td>o</td><td>八进制</td><td>[…]</td><td>所允许的字符</td></tr><tr><td>x</td><td>十六进制</td><td>p</td><td>指针</td></tr></tbody></table></li></ul></li><li><p>文件的输入和输出</p><ul><li>用 &gt; 和 &lt; 做重定向：&lt; 指定一个文件作为输入，&gt; 指定一个文件写入输出</li><li>FILE* fopen(const char8 restrict path, const char* restrict mode);</li><li>int fclose(FILE *stream);</li><li>fscanf(FILE*, …)</li><li>fprintf(FILE*, …)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp)&#123;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, ...);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>fopen</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>打开只读</td></tr><tr><td>r+</td><td>打开读写，从文件头开始</td></tr><tr><td>w</td><td>打开只写。如果不存在则新建，如果存在则清空</td></tr><tr><td>w+</td><td>打开读写。如果不存在则新建，如果存在则清空</td></tr><tr><td>a</td><td>打开追加。如果不存在则新建，如果存在则从文件尾开写</td></tr><tr><td>…x</td><td>只新建，如果文件已存在，则不能打开</td></tr></tbody></table></li></ul></li><li><p>二进制文件</p><ul><li>其实所有文件最终都是二进制</li><li>文本文件无非是最简单的方式可以读写的文件<ul><li>more、tail</li><li>cat</li><li>vi</li></ul></li><li>而二进制文件是需要专门的程序来读写的问间</li><li>文本文件的输入输出时格式化，可能经过转码</li><li>size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);</li><li>size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);</li><li>返回成功读写的字节数</li></ul></li><li><p>按位运算</p><ul><li>&amp;：按位取与<ul><li>两个数都是 1，则为 1</li><li>应用：<ul><li>让某一位或某些位置零：x &amp; 0xFE</li><li>取一个数中的一段：x &amp; 0xFF</li></ul></li></ul></li><li>|：按位取或<ul><li>有 1 则 1</li><li>应用：<ul><li>使一位或几位为 1：x | 0x01</li><li>把两个数拼起来：0x00FF | 0xFF00</li></ul></li></ul></li><li>~：按位取反<ul><li>把 1 变成 0, 0 变成 1</li><li>应用：<ul><li>想要得到全部位为 1 的数：~0</li><li>7 的二进制是 0111，x | 7 使得低 3 位为 1，而 x &amp; ~7，就使得低 3 位为 0；</li></ul></li></ul></li><li>^：按位的异或<ul><li>两位相同结果为 0，不同为 1</li><li>应用：<ul><li>如果 x 和 y 相等，那么 x^y 的结果是 0；</li><li>对于一个变量做两次异或相当于什么都没做：<ul><li>x ^ y ^ x ==&gt; y</li></ul></li></ul></li></ul></li><li>&lt;&lt;：左移<ul><li>i &lt;&lt; j：i 中所有位想左移动 j 个位置，而右边填入 0；</li><li>所有小于 int 的类型，移位以 int 方式来做结果还是 int：<ul><li>x &lt;&lt; 1 等价于 x *= 2;</li><li>x &lt;&lt; n 等价于 x *= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>;</li></ul></li></ul></li><li>&gt;&gt;：右移<ul><li>i 中所有的位向右移 j 位</li><li>所有小于 int 的类型，移位以 int 的方式来做，结果是 int</li><li>对于 unsigned 类型，左边填入 0；</li><li>对于 signed 的类型，左边填入原来最高位(保持符号不变)<ul><li>x &gt;&gt; 1 等价于 x /=2;</li><li>x &gt;&gt; n 等价于 x /= <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li></ul></li></ul></li></ul></li><li><p>位段：把一个 int 的若干位组合成一个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> leading : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> trailing : <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>可以直接用位段的成员名称来访问<ul><li>比位、与、或方便</li><li>编译器会安排其中的位的排列，不具有可移植性</li><li>当所需的位超过一个 int 时会采用多个 int</li></ul></li></ul></li><li><p>可变数组</p><ul><li>Array array_create(int init_size); // 创建</li><li>void array_free(Array *a); // 回收</li><li>int array_size(const Array *a); // 数组大小</li><li>int* array_at(Array *a, int index); // 访问某个单元</li><li>void array_inflate(Array *a, int more_size); // 增长</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; Array;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BLOCK_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Array <span class="title function_">array_create</span><span class="params">(init_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a;</span><br><span class="line">    a.size = init_size;</span><br><span class="line">    a.<span class="built_in">array</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*a.size);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_size</span><span class="params">(Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装（保护 a-&gt;size）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_size</span><span class="params">(<span class="type">const</span> Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span></span><br><span class="line">&#123;   <span class="keyword">if</span> (index &gt;= a-&gt;size)&#123;</span><br><span class="line">    array_inflate(a, (index/BLOCK_SIZE+<span class="number">1</span>)*BLOCK_SIZE - a-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)(a-&gt;size+more_size));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;a-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = a-&gt;<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">    a-&gt;<span class="built_in">array</span> = p;</span><br><span class="line">    a-&gt;size += more_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Array a = array_create(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, array_size(&amp;a));</span><br><span class="line">    *array_at(&amp;a, <span class="number">0</span>) = <span class="number">10</span>;  <span class="comment">// array_at 返回的是地址，因此直接*取地址中的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *array_at(&amp;a, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)</span><br><span class="line">            *array_at(&amp;a, cnt++) = number;</span><br><span class="line">    &#125;</span><br><span class="line">    array_free(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表：数据+指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// add to linked-list</span></span><br><span class="line">            Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            p-&gt;value = number;</span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// find the last</span></span><br><span class="line">            Node *last = head;</span><br><span class="line">            <span class="keyword">if</span> (last)&#123;</span><br><span class="line">                <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">                    last = last-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// attach</span></span><br><span class="line">                last-&gt;next = p;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; head = p ;&#125;  <span class="comment">// 初始 head = NULL，当有了第一个 p，应该指向 p</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链表函数–(以下摘抄自<a href="https://blog.csdn.net/qq_40570751/article/details/113513975?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;utm_relevant_index=3">翁恺 程序设计进阶 C 语言笔记-链表(Linked List)</a>)：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1，不行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head = p;       <span class="comment">//形参在函数结束的时候就会释放，如果没有直接将内存里的数改掉，那么对指针的操作也带不到函数外面去</span></span><br><span class="line">        <span class="comment">//在这里head是形参指针，出了函数以后head就被释放了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//证明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* t = &amp;b;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,*p);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数外：%d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* p)</span>&#123;</span><br><span class="line">    p = t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数内：%d\n&quot;</span>,*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出为</span></span><br><span class="line"><span class="comment">函数内：2</span></span><br><span class="line"><span class="comment">函数外：1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方案2，将指针的值返回</span></span><br><span class="line">Node* <span class="title function_">add</span><span class="params">(Node* head,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">head = add(head,number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案3，穿入指针的指针</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">add(&amp;head,number);   <span class="comment">//对head取地址，就是head这个指针的指针传进去了</span></span><br><span class="line"></span><br><span class="line">add(Node**  phead,<span class="type">int</span> number)&#123;     <span class="comment">//两个*，表示指针的指针</span></span><br><span class="line">    ...    <span class="comment">//head等价于*phead，将head全改为*phead</span></span><br><span class="line">    <span class="comment">//return head;   不需要返回了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案四</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list</span>&#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;   <span class="comment">//可以拓展功能，增加tail总是指向链表的末尾，然后不用遍历了，直接将tail指向新指针即可</span></span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//实现读入一个数字就存起来，知道读到-1为止</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>.head = <span class="literal">NULL</span>;    <span class="comment">//定义链表的头部，这是一个指向Node类型结构体的指针</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//添加一个新的链表（数据块）,加在程序的最后面</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)&#123;</span><br><span class="line">            add(&amp;<span class="built_in">list</span>,number);     <span class="comment">//传入指向head的指针</span></span><br><span class="line">            Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));    <span class="comment">//指针p指向新创建的链表，用malloc给他开辟内存</span></span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//新加入的链表放到最后面，所以是空指针</span></span><br><span class="line">            p-&gt;value = number;</span><br><span class="line">            <span class="comment">//找到最后的那个链表</span></span><br><span class="line">            Node *last = head;  <span class="comment">//设用last指向最后那个链表，先设last为head</span></span><br><span class="line">            <span class="comment">//last和head一样，是指向头链表的指针 *head就是头链表那个结构体 last-&gt;next 等价于 (*head).next</span></span><br><span class="line">            <span class="comment">//判断last不为空，如果整个链表为空,此时head=NULL，last-&gt;就是NULL的next元素，这样是非法的，所以要判断</span></span><br><span class="line">            <span class="keyword">if</span> (last)&#123;</span><br><span class="line">                <span class="comment">/*遍历，不能用if，这里是只要last指向的结构体的指针不为空，</span></span><br><span class="line"><span class="comment">                即指向的链表的下一个链表不为空，则不停止循环，if只判断一次*/</span></span><br><span class="line">                <span class="keyword">while</span> (last-&gt;next)&#123;</span><br><span class="line">                                last = last-&gt;next;   <span class="comment">//指向下一个链表</span></span><br><span class="line">                            &#125;</span><br><span class="line">                last-&gt;next = p;    <span class="comment">/*last-&gt;next等于NULL了，说明last已经指向原本的最后一个链表了，这里让last的next为我们新添加的链表</span></span><br><span class="line"><span class="comment">                就是将老链表的最后一个中的next指针指向我们添加的新链表*/</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = p;   <span class="comment">//空链表，直接将head指向我们新创建的链表，此时新链表是头链表，也是唯一的链表。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>( number != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(List* pList, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// add to linked-list</span></span><br><span class="line">    Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;value = number;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//find the last</span></span><br><span class="line">    Node *last = pList-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// attach</span></span><br><span class="line">        last-&gt;next = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pList-&gt;head = p;  <span class="comment">// 跟两数交换的原理一样，对指针指向的内容进行赋值(只不过赋的值是地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>链表的搜索：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(List *pList)</span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span>(p=pList-&gt;head; p; p = p-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>链表的删除：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *q;</span><br><span class="line"><span class="keyword">for</span> (q=<span class="literal">NULL</span>, p=head; p; q=p,p=p-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;value == number)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q)&#123;                     <span class="comment">// p-&gt; 中的 p 必须保证是非 NULL</span></span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">list</span>.head -&gt; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链表的清除：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p=head; p; p=q)&#123;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p></li><li><p><a href="https://www.bilibili.com/video/BV1XZ4y1S7e1/?p=1&amp;vd_source=3a9f66a8e4f96fbd39b999e86b2e0cf4">C 语言程序设计–翁恺</a></p></li><li><p><a href="https://blog.csdn.net/qq_40570751/article/details/113513975?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-113513975-blog-111396626.235%5Ev38%5Epc_relevant_anti_vip&amp;utm_relevant_index=3">翁恺 程序设计进阶 C 语言笔记-链表(Linked List)</a> 强推!!总结的很好</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCNOpen API学习笔记</title>
      <link href="/0224/08/28/TCNOpen-API%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/0224/08/28/TCNOpen-API%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><!-- ## Data Structure Index <==> 数据结构索引### API:（, ）## File Index <==> 文件索引及说明### API:（, ）## Data Structure Documentation <==> 数据结构文档### API:（, ）## File Documentation <==> 文件文档### iec61375-2-3.h File Reference <==> iec61375-2-3.h 文件参考### tau_cstinfo.c File Reference <==> tau_cstinfo.c 文件参考### tau_ctrl.c File Reference <==> tau_ctrl.c 文件参考### tau_ctrl.h File Reference <==> tau_ctrl.h 文件参考### tau_marshall.c File Reference <==> tau_marshall.c 文件参考### tau_ctrl_types.h File Reference <==> tau_ctrl_types.h 文件参考### tau_dnr.c File Reference <==> tau_dnr.c 文件参考 --><p>TRDP 是一种基于 TCP/IP 的通信协议，用于在列车控制系统中进行数据交换。它提供了一种可靠、高效的方式，使列车控制系统能够与其他设备进行通信，实现列车的自动化控制和数据采集。<br />在 TRDP（TraCommunication Network Open Protocol）中，“tlc” 和 “tlp” 通常指的是协议栈中的两个不同层次。</p><p>tlc：代表 “TraCommunication Link Control”，即列车通信链路控制层。这一层负责处理数据链路层的功能，包括数据帧的封装、传输错误的检测和纠正、流量控制等。在 TRDP 中，tlc 层提供了可靠的数据传输服务。</p><p>tlp：代表 “TraCommunication Protocol”，即列车通信协议层。这一层负责处理网络层的功能，包括路由选择、分组转发、网络地址转换等。在 TRDP 中，tlp 层提供了列车网络中的通信协议。</p><p>TLc_init 和 tlp_openSession 这两个调用实际上代表了在 TRDP 协议栈中不同层次的初始化步骤。tlc_init 函数用于初始化 tlc 层的资源，而 tlp_openSession 函数用于打开一个 tlp 层的会话，这可能涉及到网络地址的配置、连接的建立等操作。</p><p>以下是一些关键点的总结：</p><p>tlc 层负责数据链路层的功能。<br />tlp 层负责网络层的功能。<br />tlc_init 用于初始化 tlc 层。<br />tlp_openSession 用于打开 tlp 层的会话<br />TRDP 最小 DEMO：</p><h3 id="tlc_init-函数"><a class="markdownIt-Anchor" href="#tlc_init-函数"></a> tlc_init 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlc_init</span> <span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_PRINT_DBG_T pPrintDebugString,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> ∗ pRefCon,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_MEM_CONFIG_T ∗ pMemConfig)</span></span><br><span class="line">    <span class="comment">// 初始化堆区</span></span><br></pre></td></tr></table></figure><ul><li>作用：初始化 TRDP 协议栈的底层（tlc），包括内存配置和调试打印函数。</li><li>参数：<ul><li><code>pPrintDebugString</code>：指向调试打印函数的指针。</li><li><code>pRefCon</code>：用户提供的上下文指针，用于调试打印函数。</li><li><code>pMemConfig</code>：指向内存配置结构体的指针。</li></ul></li></ul><h3 id="tlc_opensession-函数"><a class="markdownIt-Anchor" href="#tlc_opensession-函数"></a> tlc_openSession 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlc_openSession</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T ∗ pAppHandle,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T ownIpAddr,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T leaderIpAddr,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_MARSHALL_CONFIG_T ∗ pMarshall,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_PD_CONFIG_T ∗ pPdDefault,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_MD_CONFIG_T ∗ pMdDefault,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> TRDP_PROCESS_CONFIG_T ∗ pProcessConfig)</span></span><br><span class="line">    <span class="comment">// 打开与TRDP堆的会话</span></span><br></pre></td></tr></table></figure><ul><li>作用：打开一个与 TRDP 堆的会话，为应用程序分配一个句柄。</li><li>参数：<ul><li><code>pAppHandle</code>：指向应用程序会话句柄的指针。</li><li><code>ownIpAddr</code>：本地设备的 IP 地址。</li><li><code>leaderIpAddr</code>：领导者设备的 IP 地址。</li><li><code>pMarshall</code>：指向编组配置结构体的指针。</li><li><code>pPdDefault</code>：指向默认过程数据（PD）配置结构体的指针。</li><li><code>pMdDefault</code>：指向默认消息数据（MD）配置结构体的指针。</li><li><code>pProcessConfig</code>：指向进程配置结构体的指针。</li></ul></li></ul><h3 id="tlp_request-函数"><a class="markdownIt-Anchor" href="#tlp_request-函数"></a> tlp_request 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_request</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_SUB_T subHandle,</span></span><br><span class="line"><span class="params">    UINT32 serviceId,</span></span><br><span class="line"><span class="params">    UINT32 comId,</span></span><br><span class="line"><span class="params">    UINT32 etbTopoCnt,</span></span><br><span class="line"><span class="params">    UINT32 opTrnTopoCnt,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T srcIpAddr,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T destIpAddr,</span></span><br><span class="line"><span class="params">    UINT32 redId,</span></span><br><span class="line"><span class="params">    TRDP_FLAGS_T pktFlags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> UINT8 ∗ pData,</span></span><br><span class="line"><span class="params">    UINT32 dataSize,</span></span><br><span class="line"><span class="params">    UINT32 replyComId,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T replyIpAddr )</span></span><br><span class="line">    <span class="comment">// 用于在 TRDP 网络中发送请求消息</span></span><br></pre></td></tr></table></figure><ul><li>作用：用于在 TRDP 网络中发送请求消息。</li><li>参数：<ul><li><code>appHandle</code>: 应用程序会话的句柄。</li><li><code>subHandle</code>: 订阅的句柄。</li><li><code>serviceId</code>: 服务 ID，标识请求的服务类型。</li><li><code>comId</code>: 通信 ID，标识请求的通信内容。</li><li><code>etbTopoCnt</code>: ETB（Ethernet Train Backbone）拓扑计数，指定消息在 ETB 网络中的传播路径。</li><li><code>opTrnTopoCnt</code>: 操作传输拓扑计数，指定消息在操作传输网络中的传播路径。</li><li><code>srcIpAddr</code>: 源 IP 地址，即发送请求的设备的 IP 地址。</li><li><code>destIpAddr</code>: 目标 IP 地址，即请求消息要发送到的设备的 IP 地址。</li><li><code>redId</code>: 冗余 ID，用于在冗余网络中标识冗余路径。</li><li><code>pktFlags</code>: 数据包标志，用于指定数据包的特殊属性，如优先级、确认要求等。</li><li><code>pData</code>: 指向数据的指针，请求消息中携带的数据。</li><li><code>dataSize</code>: 数据的大小，以字节为单位。</li><li><code>replyComId</code>: 回复通信 ID，指定期望的回复消息的通信内容。</li><li><code>replyIpAddr</code>: 回复 IP 地址，指定期望的回复消息的发送地址。</li></ul></li></ul><h3 id="tlp_subscribe-函数"><a class="markdownIt-Anchor" href="#tlp_subscribe-函数"></a> tlp_subscribe 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_subscribe</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_SUB_T ∗ pSubHandle,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> ∗ pUserRef,</span></span><br><span class="line"><span class="params">    TRDP_PD_CALLBACK_T pfCbFunction,</span></span><br><span class="line"><span class="params">    UINT32 serviceId,</span></span><br><span class="line"><span class="params">    UINT32 comId,</span></span><br><span class="line"><span class="params">    UINT32 etbTopoCnt,</span></span><br><span class="line"><span class="params">    UINT32 opTrnTopoCnt,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T srcIpAddr1,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T srcIpAddr2,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T destIpAddr,</span></span><br><span class="line"><span class="params">    TRDP_FLAGS_T pktFlags,</span></span><br><span class="line"><span class="params">    UINT32 timeout,</span></span><br><span class="line"><span class="params">    TRDP_TO_BEHAVIOR_T toBehavior)</span></span><br><span class="line"><span class="comment">// 订阅PD包</span></span><br></pre></td></tr></table></figure><ul><li>作用：订阅过程数据（PD）包。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>pSubHandle</code>：指向订阅句柄的指针。</li><li><code>pUserRef</code>：用户提供的参考值，将与信息结构一起返回。</li><li><code>pfCbFunction</code>：指向订阅者特定回调函数的指针。</li><li><code>serviceId</code>：可选的服务 ID，默认值为 0。</li><li><code>comId</code>：要接收的数据包的 COM ID。</li><li><code>etbTopoCnt</code>：ETB 拓扑计数，用于本地通信时为 0。</li><li><code>opTrnTopoCnt</code>：操作拓扑计数，用于方向敏感通信时不为 0。</li><li><code>srcIpAddr1</code>：源 IP 地址，地址范围的较低地址。</li><li><code>srcIpAddr2</code>：源 IP 地址，地址范围的较高地址。</li><li><code>destIpAddr</code>：要加入的 IP 地址。</li><li><code>pktFlags</code>：数据包标志，如默认、无、编组、回调等。</li><li><code>timeout</code>：超时时间，以微秒为单位。</li><li><code>toBehavior</code>：超时行为。</li></ul></li></ul><h3 id="tlp_publish-函数"><a class="markdownIt-Anchor" href="#tlp_publish-函数"></a> tlp_publish 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_publish</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_PUB_T ∗ pPubHandle,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> ∗ pUserRef,</span></span><br><span class="line"><span class="params">    TRDP_PD_CALLBACK_T pfCbFunction,</span></span><br><span class="line"><span class="params">    UINT32 serviceId,</span></span><br><span class="line"><span class="params">    UINT32 comId,</span></span><br><span class="line"><span class="params">    UINT32 etbTopoCnt,</span></span><br><span class="line"><span class="params">    UINT32 opTrnTopoCnt,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T srcIpAddr,</span></span><br><span class="line"><span class="params">    TRDP_IP_ADDR_T destIpAddr,</span></span><br><span class="line"><span class="params">    UINT32 interval,</span></span><br><span class="line"><span class="params">    UINT32 redId,</span></span><br><span class="line"><span class="params">    TRDP_FLAGS_T pktFlags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> UINT8 ∗ pData,</span></span><br><span class="line"><span class="params">    UINT32 dataSize )</span></span><br><span class="line">    <span class="comment">// 发布PD包</span></span><br></pre></td></tr></table></figure><ul><li>作用：发布过程数据（PD）包。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>pPubHandle</code>：指向发布句柄的指针。</li><li><code>pUserRef</code>：用户提供的参考值，将与信息结构一起返回。</li><li><code>pfCbFunction</code>：指向发布者特定回调函数的指针。</li><li><code>serviceId</code>：可选的服务 ID，默认值为 0。</li><li><code>comId</code>：要发送的数据包的 COM ID。</li><li><code>etbTopoCnt</code>：ETB 拓扑计数，用于本地通信时为 0。</li><li><code>opTrnTopoCnt</code>：操作拓扑计数，用于方向敏感通信时不为 0。</li><li><code>srcIpAddr</code>：源 IP 地址。</li><li><code>destIpAddr</code>：目标 IP 地址。</li><li><code>interval</code>：发布间隔时间。</li><li><code>redId</code>：冗余 ID。</li><li><code>pktFlags</code>：数据包标志，如默认、无、编组、回调等。</li><li><code>pData</code>：指向要发送的数据的指针。</li><li><code>dataSize</code>：数据大小，以字节为单位。</li></ul></li></ul><h3 id="tlp_getinterval-函数"><a class="markdownIt-Anchor" href="#tlp_getinterval-函数"></a> tlp_getInterval 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_getInterval</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_TIME_T ∗ pInterval,</span></span><br><span class="line"><span class="params">    TRDP_FDS_T ∗ pFileDesc,</span></span><br><span class="line"><span class="params">    TRDP_SOCK_T ∗ pNoDesc )</span></span><br><span class="line">    <span class="comment">// 获取PDs的最低时间间隔</span></span><br><span class="line">    <span class="comment">// 返回一个适合&#x27;select()&#x27;的最大时间间隔，以便我们可以及时发送到期的PD数据包。如果PD发送队列为空，返回零时间。</span></span><br></pre></td></tr></table></figure><ul><li>作用：获取过程数据（PD）包的最低发送间隔。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>pInterval</code>：指向时间间隔结构体的指针。</li><li><code>pFileDesc</code>：指向文件描述符集合的指针。</li><li><code>pNoDesc</code>：指向套接字数目的指针。</li></ul></li></ul><h3 id="vos_select-函数"><a class="markdownIt-Anchor" href="#vos_select-函数"></a> vos_select 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT32 <span class="title function_">vos_select</span><span class="params">(VOS_SOCK_T highDesc,</span></span><br><span class="line"><span class="params">    VOS_FDS_T ∗ pReadableFD,</span></span><br><span class="line"><span class="params">    VOS_FDS_T ∗ pWriteableFD,</span></span><br><span class="line"><span class="params">    VOS_FDS_T ∗ pErrorFD,</span></span><br><span class="line"><span class="params">    VOS_TIMEVAL_T ∗ pTimeOut)</span></span><br><span class="line">    <span class="comment">// 设置提供的套接字集合中的就绪套接字。注意：某些目标系统可能将此函数定义为无操作（NOP）。</span></span><br></pre></td></tr></table></figure><ul><li>作用：设置提供的套接字集合中的就绪套接字。</li><li>参数：<ul><li><code>highDesc</code>：最高描述符值加一。</li><li><code>pReadableFD</code>：指向可读文件描述符集合的指针。</li><li><code>pWriteableFD</code>：指向可写文件描述符集合的指针。</li><li><code>pErrorFD</code>：指向错误文件描述符集合的指针。</li><li><code>pTimeOut</code>：指向超时时间结构体的指针。</li></ul></li></ul><h3 id="tlc_process-函数"><a class="markdownIt-Anchor" href="#tlc_process-函数"></a> tlc_process 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlc_process</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_FDS_T ∗ pRfds,</span></span><br><span class="line"><span class="params">    INT32 ∗ pCount )</span></span><br><span class="line">    <span class="comment">// TRDP处理器的工作循环</span></span><br><span class="line">    <span class="comment">// 搜索队列中待发送的PD和MD，搜索接收队列中待处理的PD和MD（超时），然后调用适当的回调函数。</span></span><br></pre></td></tr></table></figure><ul><li>作用：TRDP 处理器的工作循环，处理发送和接收队列中的 PD 和 MD 包。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>pRfds</code>：指向文件描述符集合的指针。</li><li><code>pCount</code>：指向处理计数的指针。</li></ul></li></ul><h3 id="tlp_put-函数"><a class="markdownIt-Anchor" href="#tlp_put-函数"></a> tlp_put 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_put</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_PUB_T pubHandle,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> UINT8 ∗ pData,</span></span><br><span class="line"><span class="params">    UINT32 dataSize )</span></span><br><span class="line">    <span class="comment">// 更新要发送的进程数据</span></span><br><span class="line">    <span class="comment">// 更新先前发布的数据，最早的新的电报将在调用tlc_process时发送。</span></span><br></pre></td></tr></table></figure><ul><li>作用：更新要发送的过程数据（PD）。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>pubHandle</code>：发布句柄。</li><li><code>pData</code>：指向要发送的数据的指针。</li><li><code>dataSize</code>：数据大小，以字节为单位。</li></ul></li></ul><h3 id="tlp_get-函数"><a class="markdownIt-Anchor" href="#tlp_get-函数"></a> tlp_get 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXT_DECL TRDP_ERR_T <span class="title function_">tlp_get</span> <span class="params">(</span></span><br><span class="line"><span class="params">    TRDP_APP_SESSION_T appHandle,</span></span><br><span class="line"><span class="params">    TRDP_SUB_T subHandle,</span></span><br><span class="line"><span class="params">    TRDP_PD_INFO_T ∗ pPdInfo,</span></span><br><span class="line"><span class="params">    UINT8 ∗ pData,</span></span><br><span class="line"><span class="params">    UINT32 ∗ pDataSize )</span></span><br></pre></td></tr></table></figure><ul><li>作用：从订阅句柄中获取过程数据（PD）。</li><li>参数：<ul><li><code>appHandle</code>：应用程序会话句柄。</li><li><code>subHandle</code>：订阅句柄。</li><li><code>pPdInfo</code>：指向过程数据（PD）信息结构的指针。</li><li><code>pData</code>：指向接收数据的指针。</li><li><code>pDataSize</code>：指向接收数据大小的指针。</li></ul></li></ul><h3 id="vos_threaddelay-函数"><a class="markdownIt-Anchor" href="#vos_threaddelay-函数"></a> vos_threadDelay 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOS_ERR_T <span class="title function_">vos_threadDelay</span> <span class="params">(</span></span><br><span class="line"><span class="params">    UINT32 delay )</span></span><br></pre></td></tr></table></figure><ul><li>作用：延迟当前线程的执行，延迟时间为给定的微秒数。</li><li>参数：<ul><li><code>delay</code>：延迟时间，以微秒为单位。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRDP_NO_ERR             = <span class="number">0</span>,    <span class="comment">/**&lt; No error 没有错误 */</span></span><br><span class="line">    TRDP_PARAM_ERR          = <span class="number">-1</span>,   <span class="comment">/**&lt; Parameter missing or out of range 参数错误，参数缺失或超出范围 */</span></span><br><span class="line">    TRDP_INIT_ERR           = <span class="number">-2</span>,   <span class="comment">/**&lt; Call without valid initialization 初始化错误，调用时未进行有效初始化*/</span></span><br><span class="line">    TRDP_NOINIT_ERR         = <span class="number">-3</span>,   <span class="comment">/**&lt; Call with invalid handle 未初始化错误，使用无效句柄进行调用*/</span></span><br><span class="line">    TRDP_TIMEOUT_ERR        = <span class="number">-4</span>,   <span class="comment">/**&lt; Timout 超时错误*/</span></span><br><span class="line">    TRDP_NODATA_ERR         = <span class="number">-5</span>,   <span class="comment">/**&lt; Non blocking mode: no data received 无数据错误，在非阻塞模式下没有接收到数据*/</span></span><br><span class="line">    TRDP_SOCK_ERR           = <span class="number">-6</span>,   <span class="comment">/**&lt; Socket error / option not supported 套接字错误，套接字选项不受支持*/</span></span><br><span class="line">    TRDP_IO_ERR             = <span class="number">-7</span>,   <span class="comment">/**&lt; Socket IO error, data can&#x27;t be received/sent 套接字I/O错误，数据无法接收或发送*/</span></span><br><span class="line">    TRDP_MEM_ERR            = <span class="number">-8</span>,   <span class="comment">/**&lt; No more memory available 内存错误，没有足够的内存可用*/</span></span><br><span class="line">    TRDP_SEMA_ERR           = <span class="number">-9</span>,   <span class="comment">/**&lt; Semaphore not available 信号量错误，信号量不可用*/</span></span><br><span class="line">    TRDP_QUEUE_ERR          = <span class="number">-10</span>,  <span class="comment">/**&lt; Queue empty 队列错误，队列为空*/</span></span><br><span class="line">    TRDP_QUEUE_FULL_ERR     = <span class="number">-11</span>,  <span class="comment">/**&lt; Queue full 队列已满错误，队列已满*/</span></span><br><span class="line">    TRDP_MUTEX_ERR          = <span class="number">-12</span>,  <span class="comment">/**&lt; Mutex not available 互斥锁错误，互斥锁不可用*/</span></span><br><span class="line">    TRDP_THREAD_ERR         = <span class="number">-13</span>,  <span class="comment">/**&lt; Thread error 线程错误*/</span></span><br><span class="line">    TRDP_BLOCK_ERR          = <span class="number">-14</span>,  <span class="comment">/**&lt; System call would have blocked in blocking mode 阻塞错误，在阻塞模式下系统调用会阻塞*/</span></span><br><span class="line">    TRDP_INTEGRATION_ERR    = <span class="number">-15</span>,  <span class="comment">/**&lt; Alignment or endianess for selected target wrong 集成错误，所选目标的对齐方式或字节序错误*/</span></span><br><span class="line">    TRDP_NOCONN_ERR         = <span class="number">-16</span>,  <span class="comment">/**&lt; No TCP connection 无连接错误，没有TCP连接*/</span></span><br><span class="line">    TRDP_NOSESSION_ERR      = <span class="number">-30</span>,  <span class="comment">/**&lt; No such session 无会话错误，没有这样的会话*/</span></span><br><span class="line">    TRDP_SESSION_ABORT_ERR  = <span class="number">-31</span>,  <span class="comment">/**&lt; Session aborted 会话中止错误，会话被中止*/</span></span><br><span class="line">    TRDP_NOSUB_ERR          = <span class="number">-32</span>,  <span class="comment">/**&lt; No subscriber 无订阅错误，没有订阅者*/</span></span><br><span class="line">    TRDP_NOPUB_ERR          = <span class="number">-33</span>,  <span class="comment">/**&lt; No publisher 无发布错误，没有发布者*/</span></span><br><span class="line">    TRDP_NOLIST_ERR         = <span class="number">-34</span>,  <span class="comment">/**&lt; No listener 无监听错误，没有监听者*/</span></span><br><span class="line">    TRDP_CRC_ERR            = <span class="number">-35</span>,  <span class="comment">/**&lt; Wrong CRC CRC错误，循环冗余校验错误*/</span></span><br><span class="line">    TRDP_WIRE_ERR           = <span class="number">-36</span>,  <span class="comment">/**&lt; Wire 线路错误*/</span></span><br><span class="line">    TRDP_TOPO_ERR           = <span class="number">-37</span>,  <span class="comment">/**&lt; Invalid topo count 拓扑错误，拓扑计数无效*/</span></span><br><span class="line">    TRDP_COMID_ERR          = <span class="number">-38</span>,  <span class="comment">/**&lt; Unknown ComId ComId错误，未知的ComId*/</span></span><br><span class="line">    TRDP_STATE_ERR          = <span class="number">-39</span>,  <span class="comment">/**&lt; Call in wrong state 状态错误，在错误的状态下调用*/</span></span><br><span class="line">    TRDP_APP_TIMEOUT_ERR    = <span class="number">-40</span>,  <span class="comment">/**&lt; Application Timeout 应用程序超时错误*/</span></span><br><span class="line">    TRDP_APP_REPLYTO_ERR    = <span class="number">-41</span>,  <span class="comment">/**&lt; Application Reply Sent Timeout 应用程序回复超时错误*/</span></span><br><span class="line">    TRDP_APP_CONFIRMTO_ERR  = <span class="number">-42</span>,  <span class="comment">/**&lt; Application Confirm Sent Timeout 应用程序确认超时错误*/</span></span><br><span class="line">    TRDP_REPLYTO_ERR        = <span class="number">-43</span>,  <span class="comment">/**&lt; Protocol Reply Timeout 协议回复超时错误*/</span></span><br><span class="line">    TRDP_CONFIRMTO_ERR      = <span class="number">-44</span>,  <span class="comment">/**&lt; Protocol Confirm Timeout 协议确认超时错误*/</span></span><br><span class="line">    TRDP_REQCONFIRMTO_ERR   = <span class="number">-45</span>,  <span class="comment">/**&lt; Protocol Confirm Timeout (Request sender) 协议请求确认超时错误*/</span></span><br><span class="line">    TRDP_PACKET_ERR         = <span class="number">-46</span>,  <span class="comment">/**&lt; Incomplete message data packet 数据包错误，消息数据包不完整*/</span></span><br><span class="line">    TRDP_UNRESOLVED_ERR     = <span class="number">-47</span>,  <span class="comment">/**&lt; DNR: address could not be resolved 未解析错误，DNR：地址无法解析*/</span></span><br><span class="line">    TRDP_XML_PARSER_ERR     = <span class="number">-48</span>,  <span class="comment">/**&lt; Returned by the tau_xml subsystem XML解析器错误，由tau_xml子系统返回*/</span></span><br><span class="line">    TRDP_INUSE_ERR          = <span class="number">-49</span>,  <span class="comment">/**&lt; Resource is still in use 资源正在使用错误，资源仍在使用中*/</span></span><br><span class="line">    TRDP_MARSHALLING_ERR    = <span class="number">-50</span>,  <span class="comment">/**&lt; Source size exceeded, dataset mismatch 编组错误，源大小超出，数据集不匹配*/</span></span><br><span class="line">    TRDP_UNKNOWN_ERR        = <span class="number">-99</span>   <span class="comment">/**&lt; Unspecified error 未知错误，未指明的错误*/</span></span><br><span class="line">&#125; TRDP_ERR_T;</span><br></pre></td></tr></table></figure><ul><li>在 TRDP（Train Communication Network Open Protocol）中，MD（Message Data）和 PD（Process Data）：</li><li>Message Data：<ul><li>消息数据是指在 TRDP 网络中传输的非周期数据；</li><li>消息数据通常用于传输控制信息、数据、命令等；</li><li>MD 的发送和接收不基于固定的时间间隔，而是根据需求；</li><li>当列车系统中某个设备需要发送一个状态更新，或接收一个配置命令时，就会使用 MD 进行通信。</li></ul></li><li>Process Data：<ul><li>过程数据是指在 TRDP 网络中传输的周期数据；</li><li>用于传输实时性要求较高的过程控制数据，如传感器数据、控制信号等；</li><li>PD 消息的发送和接收是基于固定的时间间隔，通常是毫秒级的；</li><li>列车上的速度传感器会定期发送 PD 消息，以确保控制系统能够实时获取列车的速度信息。</li></ul></li></ul><h3 id="trdp-pd-test-全局变量说明"><a class="markdownIt-Anchor" href="#trdp-pd-test-全局变量说明"></a> TRDP-PD-TEST 全局变量说明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT8   *p;                                     <span class="comment">/**&lt; pointer to static or allocated memory  */</span></span><br><span class="line">    UINT32  size;                                   <span class="comment">/**&lt; size of static or allocated memory     */</span></span><br><span class="line">    UINT32  prealloc[VOS_MEM_NBLOCKSIZES];          <span class="comment">/**&lt; memory block structure                 */</span></span><br><span class="line">&#125; TRDP_MEM_CONFIG_T;</span><br></pre></td></tr></table></figure><p>结构体：内存管理结构体</p><ul><li>参数：<ul><li><code>*p</code>:指向静态或动态分配的内存。</li><li><code>size</code>:内存大小。</li><li><code>prealloc</code>:内存块结构。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Default PD configuration    */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRDP_PD_CALLBACK_T  pfCbFunction;           <span class="comment">/**&lt; Pointer to PD callback function            */</span></span><br><span class="line">    <span class="type">void</span>                *pRefCon;               <span class="comment">/**&lt; Pointer to user context for call back      */</span></span><br><span class="line">    TRDP_SEND_PARAM_T   sendParam;              <span class="comment">/**&lt; Default send parameters                    */</span></span><br><span class="line">    TRDP_FLAGS_T        flags;                  <span class="comment">/**&lt; Default flags for PD packets               */</span></span><br><span class="line">    UINT32              timeout;                <span class="comment">/**&lt; Default timeout in us                      */</span></span><br><span class="line">    TRDP_TO_BEHAVIOR_T  toBehavior;             <span class="comment">/**&lt; Default timeout behavior                  */</span></span><br><span class="line">    UINT16              port;                   <span class="comment">/**&lt; Port to be used for PD communication (default: 17224)      */</span></span><br><span class="line">&#125; TRDP_PD_CONFIG_T;</span><br></pre></td></tr></table></figure><p>结构体：PD 配置结构体</p><ul><li>参数：<ul><li><code>pfCbFunction</code>:指向 PD 回调函数的指针。</li><li><code>pRefCon</code>:指向用户上下文的指针。</li><li><code>sendParam</code>:默认发送参数。</li><li><code>flags</code>:默认 PD 包标志。</li><li><code>timeout</code>:默认超时时间（微秒）。</li><li><code>toBehavior</code>:默认超时行为。</li><li><code>port</code>:PD 通信端口（默认值：17224）。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRDP_LABEL_T        hostName;       <span class="comment">/**&lt; Host name  */</span></span><br><span class="line">    TRDP_LABEL_T        leaderName;     <span class="comment">/**&lt; Leader name dependant on redundancy concept   */</span></span><br><span class="line">    TRDP_LABEL_T        type;           <span class="comment">/**&lt; process type #349 */</span></span><br><span class="line">    UINT32              cycleTime;      <span class="comment">/**&lt; TRDP main process cycle time in us  */</span></span><br><span class="line">    UINT32              priority;       <span class="comment">/**&lt; TRDP main process priority (0-255, 0=default, 255=highest)   */</span></span><br><span class="line">    TRDP_OPTION_T       options;        <span class="comment">/**&lt; TRDP options */</span></span><br><span class="line">&#125; TRDP_PROCESS_CONFIG_T;</span><br></pre></td></tr></table></figure><p>结构体：进程配置结构体</p><ul><li>参数：<ul><li><code>hostName</code>:主机名称。</li><li><code>leaderName</code>:领导者名称依赖于冗余概念。</li><li><code>type</code>:进程类型（#349）。</li><li><code>cycleTime</code>:TRDP 主进程循环时间（微秒）。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type type;                      <span class="comment">/* port type */</span></span><br><span class="line">    TRDP_ERR_T err;                 <span class="comment">/* put/get status */</span></span><br><span class="line">    TRDP_PUB_T ph;                  <span class="comment">/* publish handle */</span></span><br><span class="line">    TRDP_SUB_T sh;                  <span class="comment">/* subscribe handle */</span></span><br><span class="line">    UINT32 comid;                   <span class="comment">/* comid            */</span></span><br><span class="line">    UINT32 repid;                   <span class="comment">/* reply comid (for PULL requests) */</span></span><br><span class="line">    UINT32 size;                    <span class="comment">/* size                            */</span></span><br><span class="line">    TRDP_IP_ADDR_T src;             <span class="comment">/* source ip address               */</span></span><br><span class="line">    TRDP_IP_ADDR_T dst;             <span class="comment">/* destination ip address          */</span></span><br><span class="line">    TRDP_IP_ADDR_T rep;             <span class="comment">/* reply ip address (for PULL requests) */</span></span><br><span class="line">    UINT32 cycle;                   <span class="comment">/* cycle                                */</span></span><br><span class="line">    UINT32 timeout;                 <span class="comment">/* timeout (for SINK ports)             */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[TRDP_MAX_PD_DATA_SIZE];       <span class="comment">/* data buffer                          */</span></span><br><span class="line">    <span class="type">int</span> link;                       <span class="comment">/* index of linked port (echo or subscribe) */</span></span><br><span class="line">&#125; Port;</span><br></pre></td></tr></table></figure><p>结构体：端口结构体</p><ul><li>参数：<ul><li><code>type</code>:端口类型。</li><li><code>err</code>:put/get 状态。</li><li><code>ph</code>:发布句柄。</li><li><code>sh</code>:订阅句柄。</li><li><code>comid</code>:comid。</li><li><code>repid</code>:回复 comid（用于 PULL 请求）。</li><li><code>size</code>:大小。</li><li><code>src</code>:源 IP 地址。</li><li><code>dst</code>:目标 IP 地址。</li><li><code>rep</code>:回复 IP 地址（用于 PULL 请求）。</li><li><code>cycle</code>:循环。</li><li><code>timeout</code>:超时（用于 SINK 端口）。</li><li><code>data</code>:数据缓冲区。</li><li><code>link</code>:链接端口的索引（回声或订阅）。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCNOpen API </tag>
            
            <tag> 列车通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
